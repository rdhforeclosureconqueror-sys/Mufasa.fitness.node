<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ma‚Äôat 2.0 Virtual Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

 <!-- TensorFlow -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6/dist/pose-detection.min.js"></script>

<!-- Calendar system (loads BEFORE index.js) -->
<script src="calendar.js"></script>

<!-- Your main fitness engine -->
<script src="index.js" type="module"></script>


  <!-- Simple favicon so we don‚Äôt get 404s -->
  <link rel="icon" href="data:,">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617; /* almost black */
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 16px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: radial-gradient(circle at top left, #111827, #020617);
      border-radius: 16px;
      border: 2px solid #facc15; /* gold outline */
      box-shadow: 0 24px 80px rgba(0,0,0,0.9);
      padding: 20px;
      display: grid;
      grid-template-columns: minmax(0, 1.25fr) minmax(0, 1fr);
      gap: 20px;
    }

    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; }
    }

    h1 { font-size: 1.6rem; margin-bottom: 4px; }
    h2 { font-size: 1.1rem; }
    .subtitle { font-size: 0.9rem; color: #9ca3af; margin-bottom: 8px; }

    .pane {
      background: rgba(15,23,42,0.95); /* deep navy */
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px solid #dc2626; /* red accent */
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .video-shell {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      border: 2px solid #16a34a; /* green edge */
    }

    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #16a34a; /* green primary */
      color: #fefce8;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, transform 0.08s ease;
    }

    button.secondary {
      background: #020617;
      border: 1px solid #f97316; /* gold/orange */
      color: #fde68a;
    }

    button:disabled { opacity: 0.5; cursor: default; }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      background: #22c55e;
    }

    .status-line { font-size: 0.8rem; color: #9ca3af; }
    .status-ok  { color: #22c55e; }
    .status-bad { color: #ef4444; }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #020617;
      border: 1px solid #facc15;
      color: #fde68a;
    }

    .chip-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34,197,94,0.9);
    }

    input[type="text"] {
      flex: 1;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      background: #020617;
      color: #e5e7eb;
      padding: 8px 12px;
      font-size: 0.9rem;
      outline: none;
    }

    input[type="text"]::placeholder { color: #6b7280; }

    select {
      width: 100%;
      border-radius: 999px;
      border: 1px solid #22c55e; /* green ring */
      background: #020617;
      color: #e5e7eb;
      padding: 6px 10px;
      font-size: 0.85rem;
      outline: none;
      margin-bottom: 4px;
    }

    #coach-log {
      flex: 1;
      min-height: 100px;
      max-height: 220px;
      overflow-y: auto;
      background: #020617;
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(31,41,55,0.9);
      font-size: 0.85rem;
    }

    #workoutPlanView,
    #ohsSummaryView,
    #profileSummary {
      border-radius: 10px;
      border: 1px solid rgba(55,65,81,0.9);
      background: #020617;
      padding: 8px 10px;
      font-size: 0.85rem;
      min-height: 50px;
      white-space: pre-wrap;
    }

    .log-line        { margin-bottom: 4px; }
    .log-line.you    { color: #e5e7eb; }
    .log-line.coach  { color: #a5b4fc; }
    .log-line.system { color: #6b7280; font-style: italic; }

    .login-row {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
    }

    /* Calendar */
    #calendarView {
      border-radius: 10px;
      border: 1px solid rgba(55,65,81,0.9);
      background: #020617;
      padding: 8px 10px;
      font-size: 0.8rem;
    }

    .cal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 0.8rem;
    }

    .cal-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
      margin-top: 4px;
    }

    .cal-dow {
      text-align: center;
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .cal-day {
      text-align: center;
      padding: 4px 0;
      border-radius: 4px;
      min-height: 22px;
    }

    .cal-empty {
      opacity: 0.2;
    }

    .cal-today {
      border: 1px solid #facc15; /* gold for today */
    }

    .cal-completed {
      background: rgba(34,197,94,0.25); /* green fill for completed workout */
      border: 1px solid #22c55e;
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- LEFT: Live video + Ma‚Äôat 2.0 coach -->
    <div class="pane">
      <h1>Pan-African Virtual Wellness Platform</h1>
      <p class="subtitle">
        The world‚Äôs first Pan-African virtual fitness platform powered by Ma‚Äôat&nbsp;2.0.
      </p>

      <div class="video-shell">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="btn-row">
        <button id="connectBtn">Connect Camera</button>
        <button id="startBtn" class="secondary" disabled>Start Workout</button>
        <button id="ohsaBtn" class="secondary" disabled>Overhead Squat Assessment</button>
        <button id="defineExerciseBtn" class="secondary" disabled>New Exercise</button>
        <button id="listenBtn" class="secondary">üéôÔ∏è Voice On</button>
        <button id="muteBtn" class="secondary">üîä Mute</button>
        <span class="chip">
          <span class="chip-dot"></span>
          <span id="brainChipText">Ma‚Äôat 2.0: connecting‚Ä¶</span>
        </span>
      </div>

      <div class="status-line"><strong>Pose:</strong> <span id="poseStatus">Not started.</span></div>
      <div class="status-line"><strong>Brain:</strong> <span id="brainStatus">Not contacted yet.</span></div>
      <div class="status-line"><strong>Exercise:</strong> <span id="exerciseLabel">Bodyweight Squat</span></div>
      <div class="status-line"><strong>Reps (this set):</strong> <span id="repCount">0</span></div>
    </div>

    <!-- RIGHT: Login + Today‚Äôs workout + Calendar + OHSA + Chat -->
    <div class="pane">
      <!-- Login / Profile -->
      <h2>Login &amp; Profile</h2>
      <p class="subtitle">Sign in so Ma‚Äôat 2.0 can remember your journey and programs.</p>

      <div class="login-row">
        <input id="userIdInput" type="text" placeholder="Enter username (e.g. rashad)..." />
        <button id="loginBtn">Sign In</button>
      </div>

      <div id="profileSummary">
        Not signed in yet. Type a username and press <strong>Sign In</strong>.
      </div>

      <!-- Today‚Äôs Workout -->
      <h2 style="margin-top:10px;">Today‚Äôs Workout</h2>
      <p class="subtitle">Choose a template or use Ma‚Äôat 2.0‚Äôs program from your assessment.</p>

      <select id="workoutSelect">
        <option value="">‚Äî Select a workout ‚Äî</option>
        <option value="static:nasm_total_body_a">NASM Total Body A (Template)</option>
        <option value="static:yoga_back_release">Yoga Back Release Flow (Template)</option>
        <!-- AI-generated programs will be added here dynamically -->
      </select>

      <div id="workoutPlanView">
        Your workout plan will appear here after you sign in and select a program.
      </div>

      <!-- Calendar -->
      <h2 style="margin-top:10px;">Workout Calendar</h2>
      <p class="subtitle">Gold = today, green = days you completed a workout.</p>
      <div id="calendarView"></div>

      <!-- OHS Summary -->
      <h2 style="margin-top:10px;">Overhead Squat Assessment</h2>
      <p class="subtitle">
        Run the assessment first. Ma‚Äôat 2.0 will read your movement and build your plan.
      </p>
      <div id="ohsSummaryView">No assessment run yet.</div>

      <!-- Chat -->
      <h2 style="margin-top:10px;">Mufasa Chat</h2>
      <p class="subtitle">Talk or type. Say ‚ÄúMufasa ‚Ä¶‚Äù or ‚ÄúCoach ‚Ä¶‚Äù for hands-free coaching.</p>
      <div style="display:flex; gap:8px;">
        <input id="questionInput" type="text" placeholder="Ask or speak to your coach..." />
        <button id="askBtn">Ask</button>
      </div>
      <div id="coach-log"></div>
    </div>
  </div>

  <script>
    console.log("üî• Ma‚Äôat 2.0 coach script initialized");

    // === Backend endpoints ===
    const BRAIN_BASE_URL = "https://mufasabrain.onrender.com";
    const ASK_URL        = BRAIN_BASE_URL + "/ask";
    const PROGRAM_URL    = BRAIN_BASE_URL + "/coach/program/generate";
    const PROGRAM_LIST   = BRAIN_BASE_URL + "/coach/program/list";
    const PROGRAM_GET    = BRAIN_BASE_URL + "/coach/program/get";
    const PROFILE_UPSERT = BRAIN_BASE_URL + "/users/profile/upsert";
    const PROFILE_GET    = BRAIN_BASE_URL + "/users/profile/get";

    const NODE_BASE_URL      = "https://mufasa-fitness-node.onrender.com";
    const NODE_COMMAND_URL   = NODE_BASE_URL + "/command";

    // === User / profile state (per-login) ===
    let currentUserId = localStorage.getItem("maat_user_id") || "";
    let userProfile   = null;   // will be object once signed in

    // Default Rashad profile ‚Äì used if you login as "rashad"
    const RASHAD_PROFILE = {
      name: "Rashad",
      age: 38,
      weight_lbs: 150,
      height: "5'5\"",
      injuries: ["3 herniated discs (lumbar)"],
      history: {
        chiropractic_months: 12,
        yoga_years: 2
      },
      goals: {
        primary: "Gain ~20 lb of muscle in 3 months",
        style: "Home workouts only + heavy yoga",
        frequency_days_per_week: 4,
        focus: "Muscle gain + back decompression / pain-free movement"
      }
    };

    // Default exercise ID for telemetry
    const EXERCISE_ID = "bodyweight_squat";

    // Workout targets for the live squat block
    const TARGET_REPS = 10;
    const TARGET_SETS = 3;

    // Static workouts (template text)
    const STATIC_WORKOUTS = {
      nasm_total_body_a:
        "Warm-up (5‚Äì10 min):\n" +
        "- Cat‚ÄìCow x10\n" +
        "- Hip circles x10/side\n" +
        "- Arm swings x20\n\n" +
        "Strength (2‚Äì3 rounds):\n" +
        "- Squat to press x12\n" +
        "- Row (band or backpack) x12\n" +
        "- Glute bridge x15\n\n" +
        "Cool-down: light stretching for hips, hamstrings, chest.",
      yoga_back_release:
        "Yoga Back Release Flow (~25 min):\n" +
        "- Child‚Äôs Pose (3‚Äì5 breaths)\n" +
        "- Cat‚ÄìCow x10\n" +
        "- Low lunge with side bend (5 breaths/side)\n" +
        "- Sphinx pose (8‚Äì10 breaths)\n" +
        "- Supine twist (5‚Äì8 breaths/side)\n" +
        "- Legs up the wall (2‚Äì3 min)."
    };

    // === DOM hooks ===
    const videoEl            = document.getElementById("video");
    const canvasEl           = document.getElementById("overlay");
    const ctx                = canvasEl.getContext("2d");
    const poseStatusEl       = document.getElementById("poseStatus");
    const brainStatusEl      = document.getElementById("brainStatus");
    const brainChipTxt       = document.getElementById("brainChipText");
    const connectBtn         = document.getElementById("connectBtn");
    const startBtn           = document.getElementById("startBtn");
    const ohsaBtn            = document.getElementById("ohsaBtn");
    const defineExerciseBtn  = document.getElementById("defineExerciseBtn");
    const muteBtn            = document.getElementById("muteBtn");
    const askBtn             = document.getElementById("askBtn");
    const questionInput      = document.getElementById("questionInput");
    const listenBtn          = document.getElementById("listenBtn");
    const logEl              = document.getElementById("coach-log");
    const repCountEl         = document.getElementById("repCount");
    const exerciseLabelEl    = document.getElementById("exerciseLabel");
    const workoutSelectEl    = document.getElementById("workoutSelect");
    const workoutPlanViewEl  = document.getElementById("workoutPlanView");
    const ohsaSummaryViewEl  = document.getElementById("ohsSummaryView");
    const calendarViewEl     = document.getElementById("calendarView");
    const userIdInputEl      = document.getElementById("userIdInput");
    const loginBtnEl         = document.getElementById("loginBtn");
    const profileSummaryEl   = document.getElementById("profileSummary");

    // === Pose / workout / voice state ===
    let detector;
    let running = false;
    let animId;

    let voiceMuted = false;
    let speechLock = false;        // true while LLM answer is speaking
    let repFeedbackAllowed = true; // rep coaching only when no LLM speech

    let listening = false;
    let recognition;
    let lastTranscript = "";

    let sessionId = null;
    let repCount = 0;
    let totalReps = 0;
    let currentSet = 1;
    let repPhase = "up";

    let fullBodyAcquired = false;
    let lastStepBackSpokenAt = 0;
    let lastGoodRepSpokenAt = 0;

    let lastNodeRepSentAt = 0;
    let lastDepthScore = 0;
    let lastGoodForm = false;

    const STEP_BACK_COOLDOWN = 4000;
    const GOOD_REP_COOLDOWN  = 2500;

    let definingExercise = false;
    let definedExercises = {};
    let currentExerciseName = null;
    const EXERCISE_BASELINE_FRAMES = 80;
    let baselineFrames = [];

    let ohsaMode = false;
    let ohsaPhase = null; // "front" or "side"
    let ohsaFrontSamples = [];
    let ohsaSideSamples  = [];
    const OHSA_TARGET_SAMPLES_PER_VIEW = 40;
    let lastOhsaSummary = null;

    // AI program text for "today"
    let aiProgramToday = null;
    let aiProgramId    = null;

    // skeleton edges for drawing
    const SKELETON_EDGES = [
      [5,7], [7,9],
      [6,8], [8,10],
      [5,6],
      [5,11], [6,12],
      [11,12],
      [11,13], [13,15],
      [12,14], [14,16]
    ];

    // === Logging / speech helpers ===
    function addLog(kind, text) {
      const div = document.createElement("div");
      div.className = "log-line " + kind;
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function stopAllSpeech() {
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
    }

    function speak(text, source = "system") {
      if (voiceMuted || !("speechSynthesis" in window)) return;
      if (speechLock && source === "rep") return;

      stopAllSpeech();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0;
      u.pitch = 1.0;

      if (source === "llm") {
        speechLock = true;
        repFeedbackAllowed = false;
      }

      u.onend = () => {
        if (source === "llm") {
          speechLock = false;
          repFeedbackAllowed = true;
        }
      };

      window.speechSynthesis.speak(u);
    }

    // === Keypoint helpers ===
    function getKeypoint(pose, name) {
      if (!pose || !pose.keypoints) return null;
      return pose.keypoints.find(k => k.name === name || k.part === name) || null;
    }

    function getAngleDegrees(a,b,c) {
      if (!a || !b || !c) return null;
      const abx = a.x - b.x, aby = a.y - b.y;
      const cbx = c.x - b.x, cby = c.y - b.y;
      const dot   = abx*cbx + aby*cby;
      const magAB = Math.hypot(abx,aby);
      const magCB = Math.hypot(cbx,cby);
      if (!magAB || !magCB) return null;
      const cos = dot / (magAB*magCB);
      const clamped = Math.min(1, Math.max(-1, cos));
      return (Math.acos(clamped) * 180) / Math.PI;
    }

    function computeKneeValgus(leftHip,rightHip,leftKnee,rightKnee) {
      if (!leftHip || !rightHip || !leftKnee || !rightKnee) return 0;
      const hipWidth  = Math.abs(rightHip.x - leftHip.x);
      const kneeWidth = Math.abs(rightKnee.x - leftKnee.x);
      if (!hipWidth) return 0;
      return (hipWidth - kneeWidth) / hipWidth;
    }

    function analyzeSquatForm(pose) {
      if (!pose) {
        return {
          fullBody:false, depthScore:0, goodForm:false,
          kneeAngle:180, torsoAngle:90, kneeValgus:0
        };
      }

      const leftHip   = getKeypoint(pose,"left_hip");
      const rightHip  = getKeypoint(pose,"right_hip");
      const leftKnee  = getKeypoint(pose,"left_knee");
      const rightKnee = getKeypoint(pose,"right_knee");
      const leftAnkle = getKeypoint(pose,"left_ankle");
      const rightAnkle= getKeypoint(pose,"right_ankle");
      const leftShoulder  = getKeypoint(pose,"left_shoulder");
      const rightShoulder = getKeypoint(pose,"right_shoulder");

      const required = [leftHip,rightHip,leftKnee,rightKnee,leftAnkle,rightAnkle];
      const fullBody = required.every(k => k && k.score > 0.3);

      const leftKneeAngle  = getAngleDegrees(leftHip,leftKnee,leftAnkle);
      const rightKneeAngle = getAngleDegrees(rightHip,rightKnee,rightAnkle);
      const kneeAngle = (leftKneeAngle + rightKneeAngle) / 2 || 180;

      const depthScore = Math.max(0, Math.min(1, (180 - kneeAngle) / 90));

      const leftTorsoAngle  = getAngleDegrees(leftShoulder,leftHip,leftAnkle);
      const rightTorsoAngle = getAngleDegrees(rightShoulder,rightHip,rightAnkle);
      const torsoAngle = (leftTorsoAngle + rightTorsoAngle) / 2 || 90;

      const kneeValgus = computeKneeValgus(leftHip,rightHip,leftKnee,rightKnee);

      const deepEnough = depthScore > 0.6;
      const notTooDeep = kneeAngle > 50;
      const torsoOk    = torsoAngle > 60;

      const goodForm = fullBody && deepEnough && notTooDeep && torsoOk;

      return { fullBody, depthScore, goodForm, kneeAngle, torsoAngle, kneeValgus };
    }

    // === Node helpers ===
    async function sendToNode(payload) {
      try {
        await fetch(NODE_COMMAND_URL, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });
      } catch (e) {
        console.warn("Node send failed", e);
      }
    }

    function sendStartSessionToNode() {
      if (!currentUserId) return;
      const body = {
        domain: "fitness",
        command: "fitness.startSession",
        userId: currentUserId,
        payload: {
          sessionId,
          programId: aiProgramId || null,
          exerciseId: EXERCISE_ID,
          ts: Date.now()
        }
      };
      sendToNode(body);
    }

    function sendEndSessionToNode() {
      if (!sessionId || !currentUserId) return;
      const body = {
        domain: "fitness",
        command: "fitness.endSession",
        userId: currentUserId,
        payload: {
          sessionId,
          repsCompleted: totalReps,
          exerciseId: EXERCISE_ID,
          ts: Date.now()
        }
      };
      sendToNode(body);
      trackWorkoutDay(); // calendar tracking
    }

    function sendRepToNode(depthScore) {
      if (!currentUserId) return;
      const now = Date.now();
      if (now - lastNodeRepSentAt < 500) return;
      lastNodeRepSentAt = now;

      const body = {
        domain: "fitness",
        command: "fitness.repUpdate",
        userId: currentUserId,
        payload: {
          sessionId,
          exerciseId: EXERCISE_ID,
          repsThisSet: repCount,
          totalReps,
          depthScore,
          ts: now
        }
      };
      sendToNode(body);
    }

    function sendOhsaToNode(summary) {
      if (!currentUserId) return;
      const body = {
        domain: "fitness",
        command: "fitness.ohsaResult",
        userId: currentUserId,
        payload: {
          summary,
          ts: Date.now()
        }
      };
      sendToNode(body);
    }

    // === Brain health check ===
    (async () => {
      try {
        const res = await fetch(BRAIN_BASE_URL + "/health");
        await res.json();
        brainStatusEl.textContent = "Ma‚Äôat 2.0 online.";
        brainStatusEl.classList.add("status-ok");
        brainChipTxt.textContent = "Ma‚Äôat 2.0";
      } catch (e) {
        console.warn("Brain health error", e);
        brainStatusEl.textContent = "Ma‚Äôat 2.0 offline.";
        brainStatusEl.classList.add("status-bad");
        brainChipTxt.textContent = "Ma‚Äôat 2.0 (offline)";
      }
    })();

    // === Camera + pose ===
    async function connectCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video:true });
        videoEl.srcObject = stream;
        await new Promise(r => videoEl.onloadedmetadata = r);
        canvasEl.width = videoEl.videoWidth;
        canvasEl.height= videoEl.videoHeight;
        poseStatusEl.textContent = "Camera connected. Loading pose detector‚Ä¶";
        await initDetector();
        poseStatusEl.textContent = "Pose detector ready.";
        poseStatusEl.classList.add("status-ok");
        startBtn.disabled = false;
        ohsaBtn.disabled = false;
        defineExerciseBtn.disabled = false;
      } catch (e) {
        console.error("Camera error", e);
        poseStatusEl.textContent = "Camera error.";
        poseStatusEl.classList.add("status-bad");
      }
    }

    async function initDetector() {
      await tf.setBackend("webgl");
      await tf.ready();
      if (typeof poseDetection === "undefined") {
        console.error("PoseDetection failed to load.");
        return;
      }
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
      console.log("‚úÖ MoveNet detector created.");
    }

    // === Brain chat (Ma‚Äôat 2.0) ===
    async function askCoach(q, options = { speakAnswer:true }) {
      if (!q) return;
      addLog("you", "You: " + q);
      questionInput.value = "";
      brainStatusEl.textContent = "Ma‚Äôat 2.0 thinking‚Ä¶";

      const telemetry = {
        exercise_id: EXERCISE_ID,
        reps: totalReps,
        depth_score: lastDepthScore,
        good_form: lastGoodForm
      };

      const ctxObj = {
        profile: userProfile,
        last_ohsa: lastOhsaSummary || null
      };

      try {
        const res = await fetch(ASK_URL, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({
            question: q,
            user_id: currentUserId || "anonymous",
            session_id: sessionId,
            telemetry,
            context: JSON.stringify(ctxObj)
          })
        });
        const data = await res.json();
        const answer = data.answer || data.response || "No response.";
        addLog("coach", "Ma‚Äôat 2.0: " + answer);
        if (options.speakAnswer) speak(answer, "llm");
        brainStatusEl.textContent = "Ma‚Äôat 2.0 responded.";
        return answer;
      } catch (e) {
        console.error("Brain error", e);
        brainStatusEl.textContent = "Ma‚Äôat 2.0 error.";
        addLog("system", "Network error contacting Ma‚Äôat 2.0.");
        return null;
      }
    }

    // === Program generation from OHSA ===
    async function generateProgramFromOhsa(summary) {
      if (!currentUserId) {
        addLog("system","Sign in before generating a program.");
        return;
      }
      try {
        const body = {
          user_id: currentUserId,
          goal: "Gain 20 lb of muscle in ~3 months with home workouts and yoga-heavy back care.",
          weeks: 12,
          days_per_week: 4,
          home_only: true,
          yoga_heavy: true,
          assessment_summary: JSON.stringify(summary),
          extra_context: "User has lumbar herniated discs and 2 years of yoga experience."
        };
        addLog("system","Sending OHSA summary to Ma‚Äôat 2.0 to build a structured program‚Ä¶");
        const res = await fetch(PROGRAM_URL, {
          method:"POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(body)
        });
        const data = await res.json();
        if (!data.ok) {
          addLog("system","Program generation failed.");
          return;
        }
        const program = data.program;
        aiProgramId    = data.program_id;
        aiProgramToday = extractTodayFromProgram(program);

        addOrUpdateAiOption(program.title || "Ma‚Äôat 2.0 ‚Äì Today‚Äôs Program");
        workoutSelectEl.value = "program:" + aiProgramId;
        workoutPlanViewEl.textContent = aiProgramToday || JSON.stringify(program,null,2);

        buildCalendarFromProgram(program);
        addLog("system","Ma‚Äôat 2.0 program saved and calendar updated.");
      } catch (e) {
        console.error("Program error", e);
        addLog("system","Error generating program from Ma‚Äôat 2.0.");
      }
    }

    function extractTodayFromProgram(program) {
      try {
        const today = new Date();
        const dow   = today.getDay(); // 0‚Äì6
        const dayIndexInWeek = dow === 0 ? 6 : dow-1; // Mon=0‚Ä¶
        const plan = program.plan || [];
        if (!plan.length) return null;

        // naive: use first week‚Äôs matching day index, else first day
        const week1 = plan[0];
        const days  = week1.days || [];
        let match = days.find(d => d.day_index === dayIndexInWeek) || days[0];
        if (!match) return null;

        let out = `**${match.label || "Today‚Äôs Session"}**\n\nFocus: ${match.focus}\n\n`;
        (match.blocks || []).forEach(b => {
          out += `${b.type.toUpperCase()} ‚Äì ${b.description}\n`;
          if (b.items && b.items.length) {
            out += "‚Ä¢ " + b.items.join("\n‚Ä¢ ") + "\n\n";
          } else {
            out += "\n";
          }
        });
        return out;
      } catch {
        return null;
      }
    }

    function addOrUpdateAiOption(label) {
      let opt = workoutSelectEl.querySelector('option[data-ai="today"]');
      if (!opt) {
        opt = document.createElement("option");
        opt.dataset.ai = "today";
        workoutSelectEl.appendChild(opt);
      }
      opt.value = "program:" + aiProgramId;
      opt.textContent = label;
    }

    // === New Exercise definition ===
    function startDefineExercise() {
      if (!detector) { alert("Connect camera first."); return; }
      if (running || ohsaMode) {
        alert("Stop workout / assessment before defining a new exercise.");
        return;
      }
      const name = prompt("Name this exercise (e.g. single_leg_squat_right):");
      if (!name) return;

      definingExercise = true;
      currentExerciseName = name;
      baselineFrames = [];
      addLog("system", `Defining new exercise: ${name}. Give several GOOD reps.`);
      speak(`Okay. Let‚Äôs define ${name}. Give me your best form for several reps.`, "rep");
    }

    function finishDefineExercise() {
      if (!definingExercise || baselineFrames.length === 0 || !currentExerciseName) return;
      const depthValues  = baselineFrames.map(f => f.depthScore);
      const torsoValues  = baselineFrames.map(f => f.torsoAngle);
      const avgDepth = depthValues.reduce((a,b)=>a+b,0)/depthValues.length;
      const avgTorso = torsoValues.reduce((a,b)=>a+b,0)/torsoValues.length;

      definedExercises[currentExerciseName] = {
        name: currentExerciseName,
        depthScoreAvg: avgDepth,
        torsoAngleAvg: avgTorso,
        samples: baselineFrames.length,
        createdAt: Date.now()
      };

      addLog("system",
        `Exercise "${currentExerciseName}" learned. Depth avg: ${avgDepth.toFixed(2)}, ` +
        `torso avg: ${avgTorso.toFixed(1)} (samples: ${baselineFrames.length}).`
      );
      speak(`Got it. I saved your baseline for ${currentExerciseName}.`, "rep");

      definingExercise = false;
      currentExerciseName = null;
      baselineFrames = [];
    }

    // === OHSA mode ===
    function startOhsa() {
      if (!detector) { alert("Connect camera first."); return; }
      if (running || definingExercise) {
        alert("Stop the workout / definition before running OHSA.");
        return;
      }

      ohsaMode = true;
      ohsaPhase = "front";
      ohsaFrontSamples = [];
      ohsaSideSamples  = [];
      lastOhsaSummary  = null;

      ohsaSummaryViewEl.textContent =
        "Running OHSA‚Ä¶ First: face the camera, arms overhead, and give 3‚Äì5 slow squats.";
      addLog("system","OHSA started: front view first.");
      speak(
        "We‚Äôre starting your overhead squat assessment. Face the camera, arms overhead, and give me three to five slow squats with your best form.",
        "rep"
      );

      runPoseLoop();
    }

    function summarizeArray(arr,key) {
      if (!arr.length) return 0;
      const vals = arr.map(a => a[key]).filter(v => typeof v === "number");
      if (!vals.length) return 0;
      return vals.reduce((a,b)=>a+b,0)/vals.length;
    }

    function finishOhsa() {
      ohsaMode = false;
      const frontDepthAvg   = summarizeArray(ohsaFrontSamples,"depthScore");
      const frontKneeValgus = summarizeArray(ohsaFrontSamples,"kneeValgus");
      const sideDepthAvg    = summarizeArray(ohsaSideSamples,"depthScore");
      const sideTorsoAngle  = summarizeArray(ohsaSideSamples,"torsoAngle");

      const findings = [];
      if (frontKneeValgus > 0.15) findings.push("Knees collapse inward (valgus) during squat.");
      if (sideTorsoAngle < 65)   findings.push("Torso leans forward more than ideal.");
      if (sideDepthAvg < 0.5 || frontDepthAvg < 0.5)
        findings.push("Squat depth is limited; may indicate ankle or hip mobility restrictions.");
      if (!findings.length)
        findings.push("Movement pattern looks generally balanced with no major OHSA faults.");

      const summary = {
        front: {
          samples: ohsaFrontSamples.length,
          depthScoreAvg: frontDepthAvg,
          kneeValgusAvg: frontKneeValgus
        },
        side: {
          samples: ohsaSideSamples.length,
          depthScoreAvg: sideDepthAvg,
          torsoAngleAvg: sideTorsoAngle
        },
        findings
      };

      lastOhsaSummary = summary;
      sendOhsaToNode(summary);

      const textSummary =
        "Overhead Squat Assessment Summary:\n" +
        `- Front samples: ${summary.front.samples}\n` +
        `  ¬∑ Avg depth score: ${summary.front.depthScoreAvg.toFixed(2)}\n` +
        `  ¬∑ Avg knee valgus: ${summary.front.kneeValgusAvg.toFixed(2)}\n` +
        `- Side samples: ${summary.side.samples}\n` +
        `  ¬∑ Avg depth score: ${summary.side.depthScoreAvg.toFixed(2)}\n` +
        `  ¬∑ Avg torso angle: ${summary.side.torsoAngleAvg.toFixed(1)}¬∞\n\n` +
        "Key findings:\n- " + findings.join("\n- ");

      ohsaSummaryViewEl.textContent = textSummary;
      addLog("system","OHSA completed. Summary recorded and sent to Ma‚Äôat 2.0 backend.");
      speak("Your overhead squat assessment is complete. I‚Äôll build your plan from this.", "rep");

      generateProgramFromOhsa(summary);
    }

    // === Pose loop ===
    async function runPoseLoop() {
      if (!running && !definingExercise && !ohsaMode) return;
      if (!detector) return;

      const poses = await detector.estimatePoses(videoEl,{ flipHorizontal:true });
      ctx.clearRect(0,0,canvasEl.width,canvasEl.height);

      const pose = poses.length ? poses[0] : null;
      const analysis = analyzeSquatForm(pose);

      lastDepthScore = analysis.depthScore;
      lastGoodForm   = analysis.goodForm;

      const now = performance.now();

      // full body cue
      if (!analysis.fullBody) {
        poseStatusEl.textContent = "No full body in view.";
        if (!fullBodyAcquired && repFeedbackAllowed &&
            now - lastStepBackSpokenAt > STEP_BACK_COOLDOWN &&
            (running || definingExercise || ohsaMode)
        ) {
          speak("Step back so I can see your whole body.", "rep");
          lastStepBackSpokenAt = now;
        }
      } else {
        if (!fullBodyAcquired) {
          fullBodyAcquired = true;
          if (repFeedbackAllowed && (running || definingExercise || ohsaMode)) {
            speak("Great, I can see your full body.", "rep");
          }
        }
        poseStatusEl.textContent = analysis.goodForm
          ? `Form looks solid. Score: ${analysis.depthScore.toFixed(2)}`
          : `Form needs adjustment. Score: ${analysis.depthScore.toFixed(2)}`;
      }

      // draw skeleton
      if (pose && pose.keypoints) {
        const color = analysis.goodForm ? "#22c55e" : "#ef4444";
        ctx.lineWidth = 3;
        for (const [i,j] of SKELETON_EDGES) {
          const kp1 = pose.keypoints[i];
          const kp2 = pose.keypoints[j];
          if (kp1 && kp2 && kp1.score > 0.4 && kp2.score > 0.4) {
            ctx.beginPath();
            ctx.moveTo(kp1.x,kp1.y);
            ctx.lineTo(kp2.x,kp2.y);
            ctx.strokeStyle = color;
            ctx.stroke();
          }
        }
        for (const kp of pose.keypoints) {
          if (kp.score > 0.4) {
            ctx.beginPath();
            ctx.arc(kp.x,kp.y,4,0,Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
          }
        }
      }

      // exercise definition capture
      if (definingExercise && analysis.fullBody && analysis.goodForm) {
        baselineFrames.push({
          depthScore: analysis.depthScore,
          torsoAngle: analysis.torsoAngle
        });
        if (baselineFrames.length === 1) {
          addLog("system","Recording exercise baseline‚Ä¶ keep moving with good form.");
        }
        if (baselineFrames.length >= EXERCISE_BASELINE_FRAMES) {
          finishDefineExercise();
        }
      }

      // OHSA sampling
      if (ohsaMode && analysis.fullBody) {
        const depth = analysis.depthScore;
        if (ohsaPhase === "front") {
          if (depth > 0.6 && ohsaFrontSamples.length < OHSA_TARGET_SAMPLES_PER_VIEW) {
            ohsaFrontSamples.push(analysis);
          }
          if (ohsaFrontSamples.length >= OHSA_TARGET_SAMPLES_PER_VIEW) {
            ohsaPhase = "side";
            addLog("system","OHSA: front view captured. Turn sideways.");
            ohsaSummaryViewEl.textContent =
              "Front view captured. Now turn sideways and give several more overhead squats.";
            speak("Good. Now turn sideways to the camera and keep squatting.", "rep");
          }
        } else if (ohsaPhase === "side") {
          if (depth > 0.6 && ohsaSideSamples.length < OHSA_TARGET_SAMPLES_PER_VIEW) {
            ohsaSideSamples.push(analysis);
          }
          if (ohsaSideSamples.length >= OHSA_TARGET_SAMPLES_PER_VIEW) {
            finishOhsa();
          }
        }
      }

      // rep detection when running workout
      if (running) {
        const depth = analysis.depthScore;
        const DOWN_THRESHOLD = 0.6;
        const UP_THRESHOLD   = 0.3;

        if (analysis.fullBody) {
          if (repPhase === "up" && depth > DOWN_THRESHOLD) {
            repPhase = "down";
          } else if (repPhase === "down" && depth < UP_THRESHOLD) {
            repPhase = "up";
            repCount += 1;
            totalReps += 1;
            repCountEl.textContent = String(repCount);
            sendRepToNode(depth);

            if (repFeedbackAllowed && now - lastGoodRepSpokenAt > GOOD_REP_COOLDOWN) {
              speak(analysis.goodForm ? "Good rep." : "Careful with your form.", "rep");
              lastGoodRepSpokenAt = now;
            }

            if (repCount === TARGET_REPS) {
              if (repFeedbackAllowed) {
                speak(`That‚Äôs ${TARGET_REPS} reps for set ${currentSet}.`, "rep");
              }
              currentSet += 1;
              if (currentSet <= TARGET_SETS) {
                repCount = 0;
                setTimeout(() => {
                  if (running && repFeedbackAllowed) {
                    speak(`Rest is over. Let‚Äôs start set ${currentSet}.`, "rep");
                  }
                }, 20000);
              } else {
                running = false;
                startBtn.textContent = "Start Workout";
                addLog("system","Workout complete.");
                if (repFeedbackAllowed) speak("Workout complete. Powerful work today.", "rep");
                sendEndSessionToNode();
                cancelAnimationFrame(animId);
                return;
              }
            }
          }
        }
      }

      animId = requestAnimationFrame(runPoseLoop);
    }

    // === Workout start/stop ===
    async function startWorkout() {
      if (!detector) return;
      if (!currentUserId) {
        alert("Sign in first so Ma‚Äôat 2.0 can track your sessions.");
        return;
      }

      if (definingExercise) {
        definingExercise = false;
        baselineFrames = [];
        currentExerciseName = null;
        addLog("system","Cancelled exercise definition to start workout.");
      }
      if (ohsaMode) {
        ohsaMode = false;
        ohsaFrontSamples = [];
        ohsaSideSamples  = [];
        addLog("system","Cancelled OHSA to start workout.");
      }

      running = !running;
      if (running) {
        sessionId = "sess_" + Date.now();
        repCount = 0;
        totalReps = 0;
        currentSet = 1;
        repPhase = "up";
        fullBodyAcquired = false;
        repCountEl.textContent = "0";
        startBtn.textContent = "Stop Workout";
        addLog("system",`Workout started: ${sessionId}`);
        speak(
          `We‚Äôre doing ${TARGET_SETS} sets of ${TARGET_REPS} squats. When you're ready, let's begin.`,
          "rep"
        );
        sendStartSessionToNode();
        runPoseLoop();
      } else {
        startBtn.textContent = "Start Workout";
        running = false;
        cancelAnimationFrame(animId);
        ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
        addLog("system","Workout stopped.");
        sendEndSessionToNode();
      }
    }

    // === STT with wake words ===
    function toggleListening() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        alert("Speech recognition not supported in this browser.");
        return;
      }
      if (!recognition) {
        recognition = new SR();
        recognition.lang = "en-US";
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onresult = e => {
          const result = e.results[e.results.length - 1];
          if (!result.isFinal) return;
          const transcript = result[0].transcript.trim();
          if (!transcript || transcript === lastTranscript) return;
          lastTranscript = transcript;
          const lower = transcript.toLowerCase();
          console.log("STT:", transcript);

          if (lower.includes("mufasa") || lower.includes("coach")) {
            stopAllSpeech();
            const cleaned = lower
              .replace("hey","")
              .replace("mufasa","")
              .replace("coach","")
              .trim();
            const msg = cleaned || "give me a quick status update on my workout.";
            addLog("you","üéôÔ∏è " + transcript);
            askCoach(msg);
          }

          if (lower.includes("start workout")) {
            if (!running) startWorkout();
          } else if (lower.includes("stop workout")) {
            if (running) startWorkout();
          } else if (lower.includes("run assessment") || lower.includes("overhead squat")) {
            if (!ohsaMode) startOhsa();
          }
        };

        recognition.onerror = e => {
          console.warn("STT error:", e.error);
          addLog("system","STT error: " + e.error);
        };

        recognition.onend = () => {
          if (listening) {
            try { recognition.start(); } catch {}
          } else {
            listenBtn.textContent = "üéôÔ∏è Voice On";
          }
        };
      }

      if (!listening) {
        listening = true;
        lastTranscript = "";
        recognition.start();
        listenBtn.textContent = "üéß Listening‚Ä¶";
        addLog("system","Listening for 'Mufasa' or 'Coach'...");
      } else {
        listening = false;
        recognition.stop();
        listenBtn.textContent = "üéôÔ∏è Voice On";
        addLog("system","Stopped listening.");
      }
    }

    // === Workout dropdown ===
    function handleWorkoutSelectChange() {
      const val = workoutSelectEl.value;
      if (!val) {
        workoutPlanViewEl.textContent =
          "Your workout plan will appear here after you sign in and select a program.";
        return;
      }

      if (val.startsWith("static:")) {
        const key = val.split(":")[1];
        workoutPlanViewEl.textContent = STATIC_WORKOUTS[key] || "Template not found.";
      } else if (val.startsWith("program:")) {
        const id = val.split(":")[1];
        if (id === aiProgramId && aiProgramToday) {
          workoutPlanViewEl.textContent = aiProgramToday;
        } else {
          // fetch from backend (in case it‚Äôs an older program)
          fetch(PROGRAM_GET + "?program_id=" + encodeURIComponent(id))
            .then(r => r.json())
            .then(data => {
              if (data.ok === false) {
                workoutPlanViewEl.textContent = "Could not load program.";
                return;
              }
              const program = data.program || data;
              const text = extractTodayFromProgram(program) ||
                           JSON.stringify(program,null,2);
              workoutPlanViewEl.textContent = text;
            })
            .catch(() => {
              workoutPlanViewEl.textContent = "Error loading program.";
            });
        }
      }
    }

    // === Calendar tracking (localStorage per user) ===
    function getSessionDaysForUser() {
      if (!currentUserId) return [];
      const key = "maat_sessions_" + currentUserId;
      try {
        return JSON.parse(localStorage.getItem(key) || "[]");
      } catch {
        return [];
      }
    }

    function trackWorkoutDay() {
      if (!currentUserId) return;
      const key = "maat_sessions_" + currentUserId;
      const todayIso = new Date().toISOString().slice(0,10);
      let days = getSessionDaysForUser();
      if (!days.includes(todayIso)) {
        days.push(todayIso);
        localStorage.setItem(key, JSON.stringify(days));
      }
      renderCalendar();
    }

    function renderCalendar() {
      const now = new Date();
      const year  = now.getFullYear();
      const month = now.getMonth(); // 0-based
      const todayIso = now.toISOString().slice(0,10);
      const completedDays = new Set(getSessionDaysForUser());

      const firstDay = new Date(year, month, 1);
      const lastDay  = new Date(year, month + 1, 0);
      const startDOW = firstDay.getDay(); // 0=Sun
      const totalDays = lastDay.getDate();

      const monthNames = [
        "January","February","March","April","May","June",
        "July","August","September","October","November","December"
      ];
      const dowNames = ["S","M","T","W","T","F","S"];

      calendarViewEl.innerHTML = "";

      const header = document.createElement("div");
      header.className = "cal-header";
      header.innerHTML = `<span>${monthNames[month]} ${year}</span>` +
                         `<span>${currentUserId ? "User: " + currentUserId : "Not signed in"}</span>`;
      calendarViewEl.appendChild(header);

      const grid = document.createElement("div");
      grid.className = "cal-grid";

      dowNames.forEach(d => {
        const cell = document.createElement("div");
        cell.className = "cal-dow";
        cell.textContent = d;
        grid.appendChild(cell);
      });

      // leading blanks
      for (let i=0; i<startDOW; i++) {
        const cell = document.createElement("div");
        cell.className = "cal-day cal-empty";
        grid.appendChild(cell);
      }

      for (let day=1; day<=totalDays; day++) {
        const cell = document.createElement("div");
        cell.className = "cal-day";
        const dateIso = new Date(year,month,day).toISOString().slice(0,10);
        if (dateIso === todayIso) cell.classList.add("cal-today");
        if (completedDays.has(dateIso)) cell.classList.add("cal-completed");
        cell.textContent = String(day);
        grid.appendChild(cell);
      }

      calendarViewEl.appendChild(grid);
    }

    // === Login / profile ===
    async function syncProfileToBrain() {
      if (!currentUserId || !userProfile) return;
      try {
        const body = {
          user_id: currentUserId,
          age: userProfile.age || undefined,
          height_cm: undefined,
          weight_kg: undefined,
          goals: userProfile.goals ? [userProfile.goals.primary] : undefined,
          injuries: userProfile.injuries || [],
          notes: userProfile.focus || ""
        };
        await fetch(PROFILE_UPSERT, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(body)
        });
      } catch (e) {
        console.warn("Profile upsert failed", e);
      }
    }

    async function loadProfileFromBrain() {
      if (!currentUserId) return null;
      try {
        const res = await fetch(PROFILE_GET + "?user_id=" +
                     encodeURIComponent(currentUserId));
        const data = await res.json();
        return data.profile || data;
      } catch {
        return null;
      }
    }

    function renderProfileSummary() {
      if (!currentUserId) {
        profileSummaryEl.textContent =
          "Not signed in yet. Type a username and press Sign In.";
        return;
      }
      const p = userProfile || {};
      const lines = [];
      lines.push(`Signed in as: ${currentUserId}`);
      if (p.age) lines.push(`Age: ${p.age}`);
      if (p.weight_lbs) lines.push(`Weight: ${p.weight_lbs} lb`);
      if (p.height) lines.push(`Height: ${p.height}`);
      if (p.goals && p.goals.primary) lines.push(`Goal: ${p.goals.primary}`);
      if (p.injuries && p.injuries.length)
        lines.push("Injuries: " + p.injuries.join(", "));
      profileSummaryEl.textContent = lines.join("\n");
    }

    async function handleLoginClick() {
      const id = (userIdInputEl.value || "").trim().toLowerCase();
      if (!id) {
        alert("Enter a username first.");
        return;
      }
      currentUserId = id;
      localStorage.setItem("maat_user_id", currentUserId);

      // seed profile
      userProfile = (id === "rashad") ? JSON.parse(JSON.stringify(RASHAD_PROFILE)) : {
        name: id,
        goals: { primary: "General fitness and wellness" },
        injuries: []
      };

      renderProfileSummary();
      renderCalendar();
      addLog("system", `Signed in as ${currentUserId}. Sending profile to Ma‚Äôat 2.0.`);
      await syncProfileToBrain();
    }

    // === Wire buttons ===
    connectBtn.onclick        = connectCamera;
    startBtn.onclick          = startWorkout;
    ohsaBtn.onclick           = startOhsa;
    defineExerciseBtn.onclick = startDefineExercise;
    askBtn.onclick            = () => askCoach(questionInput.value.trim());
    muteBtn.onclick           = () => {
      voiceMuted = !voiceMuted;
      muteBtn.textContent = voiceMuted ? "üîá Unmute" : "üîä Mute";
      if (voiceMuted) stopAllSpeech();
    };
    listenBtn.onclick         = toggleListening;
    workoutSelectEl.onchange  = handleWorkoutSelectChange;
    loginBtnEl.onclick        = handleLoginClick;

    questionInput.addEventListener("keydown", e => {
      if (e.key === "Enter") askCoach(questionInput.value.trim());
    });

    // === On load ===
    window.addEventListener("load", () => {
      exerciseLabelEl.textContent = "Bodyweight Squat";
      addLog("system","Page loaded. Connect your camera to begin.");

      if (currentUserId) {
        // restore simple profile for returning logins
        if (currentUserId === "rashad") {
          userProfile = JSON.parse(JSON.stringify(RASHAD_PROFILE));
        } else {
          userProfile = { name: currentUserId, goals:{primary:"General fitness"}, injuries:[] };
        }
        userIdInputEl.value = currentUserId;
        renderProfileSummary();
      }
      renderCalendar();

      console.log("tf loaded:", typeof tf !== "undefined");
      console.log("poseDetection loaded:", typeof poseDetection !== "undefined");
    });
  </script>
</body>
</html>
