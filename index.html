<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Black Dollar Trust "Virtual Trainer"</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- TensorFlow + Pose Detection (UMD builds) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6/dist/pose-detection.min.js"></script>

  <!-- Simple favicon so we don‚Äôt get 404s -->
  <link rel="icon" href="data:,">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 16px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: radial-gradient(circle at top left, #0f172a, #020617);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: 0 24px 80px rgba(15, 23, 42, 0.9);
      padding: 20px;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 20px;
    }

    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; }
    }

    h1 { font-size: 1.6rem; margin-bottom: 4px; }
    .subtitle { font-size: 0.9rem; color: #9ca3af; margin-bottom: 16px; }

    .pane {
      background: rgba(15, 23, 42, 0.8);
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px solid rgba(30, 64, 175, 0.6);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .video-shell {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 12px;
      overflow: hidden;
      background: #020617;
      border: 1px solid rgba(51, 65, 85, 0.8);
    }

    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #1d4ed8;
      color: white;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, transform 0.08s ease;
    }

    button.secondary {
      background: #0f172a;
      border: 1px solid #1e293b;
      color: #e5e7eb;
    }

    button:disabled { opacity: 0.5; cursor: default; }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      background: #2563eb;
    }

    .status-line { font-size: 0.8rem; color: #9ca3af; }
    .status-ok { color: #4ade80; }
    .status-bad { color: #f87171; }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(55, 65, 81, 0.9);
      color: #9ca3af;
    }

    .chip-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.9);
    }

    input[type="text"] {
      flex: 1;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      color: #e5e7eb;
      padding: 8px 12px;
      font-size: 0.9rem;
      outline: none;
    }

    input[type="text"]::placeholder { color: #6b7280; }

    #coach-log {
      flex: 1;
      min-height: 140px;
      max-height: 260px;
      overflow-y: auto;
      background: #020617;
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      font-size: 0.85rem;
    }

    .log-line { margin-bottom: 4px; }
    .log-line.you { color: #e5e7eb; }
    .log-line.coach { color: #a5b4fc; }
    .log-line.system { color: #6b7280; font-style: italic; }
  </style>
</head>

<body>
  <div class="app">
    <!-- LEFT: Live coach + video -->
    <div class="pane">
      <h1>Pan Africa Virtual Wellness Platform</h1>
      <p class="subtitle"> The Worlds First Pan African Virtual Fitness Platform </p>

      <div class="video-shell">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="btn-row">
        <button id="connectBtn">Connect Camera</button>
        <button id="startBtn" class="secondary" disabled>Start Workout</button>
        <button id="defineExerciseBtn" class="secondary" disabled>New Exercise</button>
        <button id="listenBtn" class="secondary">üéôÔ∏è Voice On</button>
        <button id="muteBtn" class="secondary">üîä Mute</button>
        <span class="chip">
          <span class="chip-dot"></span>
          <span id="brainChipText">MaaT: connecting‚Ä¶</span>
        </span>
      </div>

      <div class="status-line"><strong>Pose:</strong> <span id="poseStatus">Not started.</span></div>
      <div class="status-line"><strong>Brain:</strong> <span id="brainStatus">Not contacted yet.</span></div>
      <div class="status-line"><strong>Exercise:</strong> <span id="exerciseLabel">Bodyweight Squat</span></div>
      <div class="status-line"><strong>Reps (this set):</strong> <span id="repCount">0</span></div>
    </div>

    <!-- RIGHT: Chat -->
    <div class="pane">
      <h2 style="font-size:1.1rem;">Mufasa Chat</h2>
      <p class="subtitle">Talk or type. Say ‚ÄúMufasa ‚Ä¶‚Äù or ‚ÄúCoach ‚Ä¶‚Äù for hands-free coaching.</p>
      <div style="display:flex; gap:8px;">
        <input id="questionInput" type="text" placeholder="Ask or speak to your coach..." />
        <button id="askBtn">Ask</button>
      </div>
      <div id="coach-log"></div>
    </div>
  </div>

  <script>
    console.log("üî• Mufasa Coach script initialized");

    // --- Backend endpoints ---
    const BRAIN_BASE_URL = "https://mufasabrain.onrender.com";
    const ASK_URL = BRAIN_BASE_URL + "/ask";

    const NODE_BASE_URL = "https://mufasa-fitness-node.onrender.com";
    const NODE_COMMAND_URL = NODE_BASE_URL + "/command";

    const USER_ID = "rashad";
    const EXERCISE_ID = "bodyweight_squat";

    // Workout plan
    const TARGET_REPS = 10;
    const TARGET_SETS = 3;

    // --- DOM hooks ---
    const videoEl = document.getElementById("video");
    const canvasEl = document.getElementById("overlay");
    const ctx = canvasEl.getContext("2d");
    const poseStatusEl = document.getElementById("poseStatus");
    const brainStatusEl = document.getElementById("brainStatus");
    const brainChipTxt = document.getElementById("brainChipText");
    const connectBtn = document.getElementById("connectBtn");
    const startBtn = document.getElementById("startBtn");
    const defineExerciseBtn = document.getElementById("defineExerciseBtn");
    const muteBtn = document.getElementById("muteBtn");
    const askBtn = document.getElementById("askBtn");
    const questionInput = document.getElementById("questionInput");
    const listenBtn = document.getElementById("listenBtn");
    const logEl = document.getElementById("coach-log");
    const repCountEl = document.getElementById("repCount");
    const exerciseLabelEl = document.getElementById("exerciseLabel");

    // --- State ---
    let detector;
    let running = false;
    let animId;

    let voiceMuted = false;

    // Speech / LLM orchestration
    let speechLock = false;        // true while LLM answer is playing
    let repFeedbackAllowed = true; // rep voice allowed when no LLM talking

    // STT state
    let listening = false;
    let recognition;
    let lastTranscript = "";

    // Workout state
    let sessionId = null;
    let repCount = 0;      // this set
    let totalReps = 0;     // across all sets
    let currentSet = 1;
    let repPhase = "up";   // "up" -> "down" -> "up"

    let fullBodyAcquired = false;
    let lastStepBackSpokenAt = 0;
    let lastGoodRepSpokenAt = 0;

    let lastNodeRepSentAt = 0;
    let lastDepthScore = 0;
    let lastGoodForm = false;

    const STEP_BACK_COOLDOWN = 4000;  // ms
    const GOOD_REP_COOLDOWN  = 2500;  // ms (a bit less chatty)

    // --- New Exercise definition state ---
    let definingExercise = false;
    let definedExercises = {};        // { name: { depthScoreAvg, torsoAngleAvg, samples, createdAt } }
    let currentExerciseName = null;
    const EXERCISE_BASELINE_FRAMES = 80; // approx frames of "good form" to collect
    let baselineFrames = [];          // { depthScore, torsoAngle }

    // skeleton edges for MoveNet keypoints (indices 0‚Äì16)
    const SKELETON_EDGES = [
      [5, 7], [7, 9],        // left arm
      [6, 8], [8, 10],       // right arm
      [5, 6],                // shoulders
      [5, 11], [6, 12],      // torso
      [11, 12],              // hips
      [11, 13], [13, 15],    // left leg
      [12, 14], [14, 16]     // right leg
    ];

    // --- Helpers ---
    function addLog(kind, text) {
      const div = document.createElement("div");
      div.className = "log-line " + kind;
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function stopAllSpeech() {
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel(); // kill queued + current
      }
    }

    /**
     * speak(text, source)
     * source: "rep" (auto coaching), "llm" (brain answer), "system"
     */
    function speak(text, source = "system") {
      if (voiceMuted || !("speechSynthesis" in window)) return;

      // Prevent rep-loop from speaking over an LLM answer
      if (speechLock && source === "rep") return;

      // Always clear old queue so we don't stack old prompts
      stopAllSpeech();

      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0;
      u.pitch = 1.0;

      if (source === "llm") {
        speechLock = true;
        repFeedbackAllowed = false;
      }

      u.onend = () => {
        if (source === "llm") {
          speechLock = false;
          repFeedbackAllowed = true;
        }
      };

      window.speechSynthesis.speak(u);
    }

    function getKeypoint(pose, name) {
      if (!pose || !pose.keypoints) return null;
      return pose.keypoints.find(k => k.name === name || k.part === name) || null;
    }

    function getAngleDegrees(a, b, c) {
      if (!a || !b || !c) return null;
      const abx = a.x - b.x;
      const aby = a.y - b.y;
      const cbx = c.x - b.x;
      const cby = c.y - b.y;
      const dot = abx * cbx + aby * cby;
      const magAB = Math.hypot(abx, aby);
      const magCB = Math.hypot(cbx, cby);
      if (!magAB || !magCB) return null;
      const cos = dot / (magAB * magCB);
      const clamped = Math.min(1, Math.max(-1, cos));
      return (Math.acos(clamped) * 180) / Math.PI;
    }

    // Analyze squat form ‚Üí fullBody, depthScore, goodForm, kneeAngle, torsoAngle
    function analyzeSquatForm(pose) {
      if (!pose) return {
        fullBody: false,
        depthScore: 0,
        goodForm: false,
        kneeAngle: 180,
        torsoAngle: 90
      };

      const leftHip   = getKeypoint(pose, "left_hip");
      const rightHip  = getKeypoint(pose, "right_hip");
      const leftKnee  = getKeypoint(pose, "left_knee");
      const rightKnee = getKeypoint(pose, "right_knee");
      const leftAnkle = getKeypoint(pose, "left_ankle");
      const rightAnkle= getKeypoint(pose, "right_ankle");
      const leftShoulder  = getKeypoint(pose, "left_shoulder");
      const rightShoulder = getKeypoint(pose, "right_shoulder");

      const required = [leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle];
      const fullBody = required.every(k => k && k.score > 0.3);

      const leftKneeAngle  = getAngleDegrees(leftHip,  leftKnee,  leftAnkle);
      const rightKneeAngle = getAngleDegrees(rightHip, rightKnee, rightAnkle);
      const kneeAngle = (leftKneeAngle + rightKneeAngle) / 2 || 180;

      // map 180 (standing) ‚Üí 0, 90 (deep) ‚Üí ~1
      const depthScore = Math.max(0, Math.min(1, (180 - kneeAngle) / 90));

      const leftTorsoAngle  = getAngleDegrees(leftShoulder,  leftHip,  leftAnkle);
      const rightTorsoAngle = getAngleDegrees(rightShoulder, rightHip, rightAnkle);
      const torsoAngle = (leftTorsoAngle + rightTorsoAngle) / 2 || 90;

      const deepEnough = depthScore > 0.6;
      const notTooDeep = kneeAngle > 50;
      const torsoOk    = torsoAngle > 60;

      const goodForm = fullBody && deepEnough && notTooDeep && torsoOk;

      return { fullBody, depthScore, goodForm, kneeAngle, torsoAngle };
    }

    // --- Node telemetry helpers ---
    async function sendToNode(payload) {
      try {
        await fetch(NODE_COMMAND_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
      } catch (e) {
        console.warn("Node send failed", e);
      }
    }

    function sendStartSessionToNode() {
      const body = {
        domain: "fitness",
        command: "fitness.startSession",
        userId: USER_ID,
        payload: {
          sessionId,
          programId: null,
          exerciseId: EXERCISE_ID,
          ts: Date.now()
        }
      };
      sendToNode(body);
    }

    function sendEndSessionToNode() {
      if (!sessionId) return;
      const body = {
        domain: "fitness",
        command: "fitness.endSession",
        userId: USER_ID,
        payload: {
          sessionId,
          repsCompleted: totalReps,
          exerciseId: EXERCISE_ID,
          ts: Date.now()
        }
      };
      sendToNode(body);
    }

    function sendRepToNode(depthScore) {
      const now = Date.now();
      if (now - lastNodeRepSentAt < 500) return;  // throttle
      lastNodeRepSentAt = now;

      const body = {
        domain: "fitness",
        command: "fitness.repUpdate",
        userId: USER_ID,
        payload: {
          sessionId,
          exerciseId: EXERCISE_ID,
          repsThisSet: repCount,
          totalReps,
          depthScore,
          ts: now
        }
      };
      sendToNode(body);
    }

    // --- Brain health check ---
    (async () => {
      try {
        const res = await fetch(BRAIN_BASE_URL + "/health");
        const data = await res.json();
        brainStatusEl.textContent = `Phase ${data.phase}, model ${data.openai_model}`;
        brainChipTxt.textContent = `Brain: phase ${data.phase} ¬∑ ${data.openai_model}`;
      } catch (e) {
        console.warn("Brain health error", e);
        brainStatusEl.textContent = "Brain offline.";
        brainChipTxt.textContent = "Brain: offline";
      }
    })();

    // --- Camera + Pose ---
    async function connectCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoEl.srcObject = stream;
        await new Promise(r => videoEl.onloadedmetadata = r);
        canvasEl.width = videoEl.videoWidth;
        canvasEl.height = videoEl.videoHeight;
        poseStatusEl.textContent = "Camera connected. Loading pose detector‚Ä¶";
        await initDetector();
        poseStatusEl.textContent = "Pose detector ready.";
        poseStatusEl.classList.add("status-ok");
        startBtn.disabled = false;
        defineExerciseBtn.disabled = false;
      } catch (e) {
        console.error("Camera error", e);
        poseStatusEl.textContent = "Camera error.";
        poseStatusEl.classList.add("status-bad");
      }
    }

    async function initDetector() {
      await tf.setBackend("webgl");
      await tf.ready();
      if (typeof poseDetection === "undefined") {
        console.error("PoseDetection failed to load.");
        return;
      }
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
      console.log("‚úÖ MoveNet detector created.");
    }

    // --- Ask coach via Ma‚Äôat (with telemetry) ---
    async function askCoach(q) {
      if (!q) return;
      addLog("you", "You: " + q);
      questionInput.value = "";
      brainStatusEl.textContent = "Thinking‚Ä¶";

      const telemetry = {
        exercise_id: EXERCISE_ID,
        reps: totalReps,
        depth_score: lastDepthScore,
        good_form: lastGoodForm
      };

      try {
        const res = await fetch(ASK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            question: q,
            user_id: USER_ID,
            session_id: sessionId,
            telemetry
          })
        });
        const data = await res.json();
        const answer = data.answer || data.response || "No response.";
        addLog("coach", "Mufasa: " + answer);
        speak(answer, "llm");
        brainStatusEl.textContent = "Coach responded.";
      } catch (e) {
        console.error("Brain error", e);
        brainStatusEl.textContent = "Brain error.";
        addLog("system", "Network error contacting brain.");
      }
    }

    // --- New Exercise Definition Mode ---
    function startDefineExercise() {
      if (!detector) {
        alert("Connect camera first.");
        return;
      }
      if (running) {
        alert("Stop the workout before defining a new exercise.");
        return;
      }

      const name = prompt("Name this exercise (e.g. single_leg_squat_right):");
      if (!name) return;

      definingExercise = true;
      currentExerciseName = name;
      baselineFrames = [];
      addLog("system", `Defining new exercise: ${name}. Give me several GOOD reps.`);
      speak(
        `Okay Rashad. Let's define ${name}. Give me your best form for several reps so I can learn this move.`,
        "rep"
      );

      // make sure pose loop is running while capturing
      runPoseLoop();
    }

    function finishDefineExercise() {
      if (!definingExercise || baselineFrames.length === 0 || !currentExerciseName) return;

      const depthValues = baselineFrames.map(f => f.depthScore);
      const torsoValues = baselineFrames.map(f => f.torsoAngle);
      const avgDepth = depthValues.reduce((a, b) => a + b, 0) / depthValues.length;
      const avgTorso = torsoValues.reduce((a, b) => a + b, 0) / torsoValues.length;

      definedExercises[currentExerciseName] = {
        name: currentExerciseName,
        depthScoreAvg: avgDepth,
        torsoAngleAvg: avgTorso,
        samples: baselineFrames.length,
        createdAt: Date.now()
      };

      addLog(
        "system",
        `Exercise "${currentExerciseName}" learned. Depth avg: ${avgDepth.toFixed(
          2
        )}, torso avg: ${avgTorso.toFixed(1)} (samples: ${baselineFrames.length}).`
      );
      speak(
        `Got it. I saved your baseline for ${currentExerciseName}. We'll use this to judge form later.`,
        "rep"
      );
      console.log("Defined exercises:", definedExercises);

      definingExercise = false;
      currentExerciseName = null;
      baselineFrames = [];
    }

    // --- Pose loop with squat reps + form feedback + exercise capture ---
    async function runPoseLoop() {
      if (!running && !definingExercise) return;
      if (!detector) return;

      const poses = await detector.estimatePoses(videoEl, { flipHorizontal: true });
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

      const pose = poses.length ? poses[0] : null;
      let analysis = {
        fullBody: false,
        depthScore: 0,
        goodForm: false,
        kneeAngle: 180,
        torsoAngle: 90
      };
      if (pose) analysis = analyzeSquatForm(pose);

      lastDepthScore = analysis.depthScore;
      lastGoodForm = analysis.goodForm;

      const now = performance.now();

      // 1) Step-back vs guiding (running or defining)
      if (!analysis.fullBody) {
        poseStatusEl.textContent = "No full body in view.";
        if (!fullBodyAcquired && repFeedbackAllowed && now - lastStepBackSpokenAt > STEP_BACK_COOLDOWN) {
          if (running || definingExercise) {
            speak("Step back so I can see your whole body.", "rep");
          }
          lastStepBackSpokenAt = now;
        }
      } else {
        if (!fullBodyAcquired) {
          fullBodyAcquired = true;
          if (repFeedbackAllowed && (running || definingExercise)) {
            speak("Great, I can see your full body.", "rep");
          }
        }
        poseStatusEl.textContent = analysis.goodForm
          ? `Form looks solid. Score: ${analysis.depthScore.toFixed(2)}`
          : `Form needs adjustment. Score: ${analysis.depthScore.toFixed(2)}`;
      }

      // 2) Draw skeleton in green/red
      if (pose && pose.keypoints) {
        const color = analysis.goodForm ? "#22c55e" : "#ef4444";
        ctx.lineWidth = 3;

        for (const [i, j] of SKELETON_EDGES) {
          const kp1 = pose.keypoints[i];
          const kp2 = pose.keypoints[j];
          if (kp1 && kp2 && kp1.score > 0.4 && kp2.score > 0.4) {
            ctx.beginPath();
            ctx.moveTo(kp1.x, kp1.y);
            ctx.lineTo(kp2.x, kp2.y);
            ctx.strokeStyle = color;
            ctx.stroke();
          }
        }

        for (const kp of pose.keypoints) {
          if (kp.score > 0.4) {
            ctx.beginPath();
            ctx.arc(kp.x, kp.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
          }
        }
      }

      // 3) If defining exercise, capture good-form frames
      if (definingExercise && analysis.fullBody && analysis.goodForm) {
        baselineFrames.push({
          depthScore: analysis.depthScore,
          torsoAngle: analysis.torsoAngle
        });

        if (baselineFrames.length === 1) {
          addLog("system", "Recording baseline‚Ä¶ keep moving with good form.");
        }

        if (baselineFrames.length >= EXERCISE_BASELINE_FRAMES) {
          finishDefineExercise();
        }
      }

      // 4) Rep detection (only when running workout)
      if (running) {
        const depth = analysis.depthScore;
        const DOWN_THRESHOLD = 0.6;
        const UP_THRESHOLD   = 0.3;

        if (analysis.fullBody) {
          if (repPhase === "up" && depth > DOWN_THRESHOLD) {
            repPhase = "down"; // reached bottom
          } else if (repPhase === "down" && depth < UP_THRESHOLD) {
            repPhase = "up";   // came back up ‚Üí count rep
            repCount += 1;
            totalReps += 1;
            repCountEl.textContent = String(repCount);
            sendRepToNode(depth);

            // Voice rep feedback ‚Äì light, rate-limited
            if (repFeedbackAllowed && now - lastGoodRepSpokenAt > GOOD_REP_COOLDOWN) {
              if (analysis.goodForm) {
                speak("Good rep.", "rep");
              } else {
                speak("Careful with your form on that rep.", "rep");
              }
              lastGoodRepSpokenAt = now;
            }

            // Set / rep targets
            if (repCount === TARGET_REPS) {
              if (repFeedbackAllowed) {
                speak(
                  `Great job. That's ${TARGET_REPS} reps for set ${currentSet}.`,
                  "rep"
                );
              }
              currentSet += 1;

              if (currentSet <= TARGET_SETS) {
                // new set
                repCount = 0;
                setTimeout(() => {
                  if (running && repFeedbackAllowed) {
                    speak(`Rest is over. Let's start set ${currentSet}.`, "rep");
                  }
                }, 20000); // simple 20s rest
              } else {
                // workout complete
                running = false;
                startBtn.textContent = "Start Workout";
                addLog("system", "Workout complete.");
                if (repFeedbackAllowed) {
                  speak("Workout complete. Incredible focus today.", "rep");
                }
                sendEndSessionToNode();
                cancelAnimationFrame(animId);
                return; // stop loop
              }
            }
          }
        }
      }

      animId = requestAnimationFrame(runPoseLoop);
    }

    // --- Workout start/stop ---
    async function startWorkout() {
      if (!detector) return;

      // If we are in define mode, stop it
      if (definingExercise) {
        definingExercise = false;
        baselineFrames = [];
        currentExerciseName = null;
        addLog("system", "Cancelled exercise definition to start workout.");
      }

      running = !running;

      if (running) {
        sessionId = "sess_" + Date.now();
        repCount = 0;
        totalReps = 0;
        currentSet = 1;
        repPhase = "up";
        fullBodyAcquired = false;
        repCountEl.textContent = "0";
        startBtn.textContent = "Stop Workout";
        addLog("system", `Workout started: ${sessionId}`);
        speak(
          `We are doing ${TARGET_SETS} sets of ${TARGET_REPS} squats. When you're ready, let's begin.`,
          "rep"
        );
        sendStartSessionToNode();
        runPoseLoop();
      } else {
        startBtn.textContent = "Start Workout";
        running = false;
        cancelAnimationFrame(animId);
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        addLog("system", "Workout stopped.");
        sendEndSessionToNode();
      }
    }

    // --- STT with wake words ‚ÄúMufasa / Coach‚Äù ---
    function toggleListening() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        alert("Speech recognition not supported in this browser.");
        return;
      }

      if (!recognition) {
        recognition = new SR();
        recognition.lang = "en-US";
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onresult = e => {
          const result = e.results[e.results.length - 1];
          if (!result.isFinal) return;

          const transcript = result[0].transcript.trim();
          if (!transcript || transcript === lastTranscript) return;
          lastTranscript = transcript;

          const lower = transcript.toLowerCase();
          console.log("STT:", transcript);

          // Wake words ‚Äì also act as "stop talking and listen"
          if (lower.includes("mufasa") || lower.includes("coach")) {
            stopAllSpeech();   // üî• kill old speech immediately

            const cleaned = lower
              .replace("hey", "")
              .replace("mufasa", "")
              .replace("coach", "")
              .trim();

            const msg = cleaned || "give me a quick status update on my workout.";
            addLog("you", "üéôÔ∏è " + transcript);
            askCoach(msg);
          }

          // Voice controls
          if (lower.includes("start workout")) {
            if (!running) startWorkout();
          } else if (lower.includes("stop workout")) {
            if (running) startWorkout(); // toggles off
          }
        };

        recognition.onerror = e => {
          console.warn("STT error:", e.error);
          addLog("system", "STT error: " + e.error);
        };

        recognition.onend = () => {
          if (listening) {
            try { recognition.start(); } catch {}
          } else {
            listenBtn.textContent = "üéôÔ∏è Voice On";
          }
        };
      }

      if (!listening) {
        listening = true;
        lastTranscript = "";
        recognition.start();
        listenBtn.textContent = "üéß Listening‚Ä¶";
        addLog("system", "Listening for 'Mufasa' or 'Coach'...");
      } else {
        listening = false;
        recognition.stop();
        listenBtn.textContent = "üéôÔ∏è Voice On";
        addLog("system", "Stopped listening.");
      }
    }

    // --- Wire buttons ---
    connectBtn.onclick = connectCamera;
    startBtn.onclick = startWorkout;
    defineExerciseBtn.onclick = startDefineExercise;
    askBtn.onclick = () => askCoach(questionInput.value.trim());
    muteBtn.onclick = () => {
      voiceMuted = !voiceMuted;
      muteBtn.textContent = voiceMuted ? "üîá Unmute" : "üîä Mute";
      if (voiceMuted) stopAllSpeech();
    };
    listenBtn.onclick = toggleListening;
    questionInput.addEventListener("keydown", e => {
      if (e.key === "Enter") askCoach(questionInput.value.trim());
    });

    // --- On load ---
    window.addEventListener("load", () => {
      exerciseLabelEl.textContent = "Bodyweight Squat";
      addLog("system", "Page loaded. Connect your camera to begin.");
      console.log("tf loaded:", typeof tf !== "undefined");
      console.log("poseDetection loaded:", typeof poseDetection !== "undefined");
    });
  </script>
</body>
</html>
