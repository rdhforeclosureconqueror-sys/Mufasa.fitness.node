<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pocket PT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Google Identity (optional Google sign-in) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- TensorFlow + Pose Detection (UMD builds) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6/dist/pose-detection.min.js"></script>

  <!-- Simple favicon so we don‚Äôt get 404s -->
  <link rel="icon" href="data:,">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 16px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: radial-gradient(circle at top left, #020617, #000000);
      border-radius: 16px;
      border: 2px solid #facc15;
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.9);
      padding: 20px;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 20px;
    }

    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; }
    }

    h1 { font-size: 1.6rem; margin-bottom: 4px; }
    h2 { font-size: 1.1rem; }
    .subtitle { font-size: 0.9rem; color: #9ca3af; margin-bottom: 12px; }

    .pane {
      background: rgba(3, 7, 18, 0.95);
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px solid #facc15;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .video-shell {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      border: 1px solid #22c55e;
    }

    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #22c55e;
      color: #0b1120;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, transform 0.08s ease;
    }

    button.secondary {
      background: #020617;
      border: 1px solid #ef4444;
      color: #fecaca;
    }

    button:disabled { opacity: 0.5; cursor: default; }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      background: #16a34a;
      color: #ecfdf5;
    }

    .status-line { font-size: 0.8rem; color: #9ca3af; }
    .status-ok { color: #22c55e; }
    .status-bad { color: #ef4444; }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #020617;
      border: 1px solid #facc15;
      color: #fde68a;
    }

    .chip-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.9);
    }

    input[type="text"] {
      flex: 1;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      color: #e5e7eb;
      padding: 8px 12px;
      font-size: 0.9rem;
      outline: none;
    }

    input[type="text"]::placeholder { color: #6b7280; }

    select {
      width: 100%;
      border-radius: 999px;
      border: 1px solid #facc15;
      background: #020617;
      color: #e5e7eb;
      padding: 6px 10px;
      font-size: 0.85rem;
      outline: none;
    }

    #voiceSelect {
      width: auto;
      min-width: 120px;
      max-width: 220px;
    }

    #coach-log {
      flex: 1;
      min-height: 120px;
      max-height: 260px;
      overflow-y: auto;
      background: #020617;
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      font-size: 0.85rem;
    }

    #workoutPlanView, #ohsSummaryView {
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      padding: 8px 10px;
      font-size: 0.85rem;
      min-height: 60px;
      white-space: pre-wrap;
    }

    .log-line { margin-bottom: 4px; }
    .log-line.you { color: #e5e7eb; }
    .log-line.coach { color: #a5b4fc; }
    .log-line.system { color: #6b7280; font-style: italic; }

    /* ---- Calendar ---- */
    #calendarView {
      margin-top: 4px;
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      padding: 6px 8px;
      font-size: 0.75rem;
    }

    .cal-header {
      text-align: center;
      margin-bottom: 4px;
      font-weight: 600;
      color: #facc15;
    }

    .cal-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 3px;
    }

    .cal-day-label {
      text-align: center;
      color: #9ca3af;
      font-size: 0.7rem;
    }

    .cal-cell {
      min-height: 32px;
      border-radius: 6px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      text-align: center;
      padding: 2px;
      cursor: default;
    }

    .cal-empty { border: none; background: transparent; }

    .cal-date { font-size: 0.75rem; }

    .cal-today {
      border-color: #facc15;
      box-shadow: 0 0 8px rgba(250, 204, 21, 0.6);
    }

    .cal-workout {
      background: rgba(34, 197, 94, 0.18);
      border-color: #22c55e;
    }

    .cal-done {
      background: #22c55e;
      border-color: #22c55e;
      color: #022c22;
      font-weight: 600;
    }

    .small-card {
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      padding: 6px 8px;
      font-size: 0.8rem;
    }

    /* ---- LOGIN OVERLAY ---- */
    #loginOverlay {
      position: fixed;
      inset: 0;
      backdrop-filter: blur(8px) brightness(0.4);
      background: rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      flex-direction: column;
      transition: opacity 0.4s ease;
    }
    #loginOverlay.hidden { opacity: 0; pointer-events: none; }

    #loginBox {
      background: radial-gradient(circle at top, #020617, #000000);
      border: 2px solid #facc15;
      border-radius: 20px;
      padding: 32px 40px;
      text-align: center;
      box-shadow: 0 0 40px rgba(250,204,21,0.4);
      color: #facc15;
      max-width: 360px;
    }
    #loginBox h1 {
      color: #facc15;
      font-size: 1.4rem;
      margin-bottom: 10px;
    }
    #loginBox p {
      font-size: 0.9rem;
      color: #fde68a;
      margin-bottom: 16px;
    }
    #googleBtn {
      margin-top: 10px;
      background: linear-gradient(90deg,#ef4444,#16a34a);
      color: #fff;
      border: 2px solid #facc15;
      border-radius: 999px;
      padding: 10px 18px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .3s ease;
    }
    #googleBtn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px #facc15;
    }

    #userInfo {
      position: fixed;
      top: 8px;
      right: 14px;
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 2000;
    }
    #userInfo img {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid #facc15;
    }
    #userName {
      color: #facc15;
      font-weight: 600;
      font-size: 0.85rem;
    }
    #signOutBtn {
      background: #ef4444;
      border: none;
      border-radius: 999px;
      color: #fff;
      padding: 4px 10px;
      font-size: .75rem;
      cursor: pointer;
    }
    #signOutBtn:hover { background: #b91c1c; }

    #voiceSupportStatus {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 4px;
    }
  </style>
</head>

<body>
  <!-- LOGIN OVERLAY -->
  <div id="loginOverlay">
    <div id="loginBox">
      <h1>Enter the Mufasa Realm üî•</h1>
      <p>Sign in to unlock your Pocket PT 2.0 dashboard.</p>

      <div style="margin-bottom:10px;">
        <input id="manualName" type="text"
               placeholder="Type a username (e.g. rashad)‚Ä¶"
               style="width:100%;margin-bottom:8px;" />
        <button id="manualLoginBtn" style="width:100%;">Continue</button>
      </div>

      <div style="font-size:0.75rem;color:#9ca3af;margin:6px 0;">‚Äî or ‚Äî</div>
      <button id="googleBtn">Continue with Google</button>
    </div>
  </div>

  <!-- USER INFO BAR -->
  <div id="userInfo">
    <img id="userPic" src="" alt="profile" />
    <span id="userName"></span>
    <button id="signOutBtn">Sign out</button>
  </div>

  <!-- MAIN APP -->
  <div class="app">
    <!-- LEFT: Live coach + video -->
    <div class="pane">
      <h1>Pocket PT Virtual Wellness Platform</h1>
      <p class="subtitle">
        Pocket PT virtual fitness platform powered by Simba Wa Ujamaa &nbsp;2.0.
      </p>

      <div class="video-shell">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="btn-row">
        <button id="connectBtn">Connect Camera</button>
        <button id="startBtn" class="secondary" disabled>Start Workout</button>
        <button id="ohsaBtn" class="secondary" disabled>Overhead Squat Assessment</button>
        <button id="defineExerciseBtn" class="secondary" disabled>New Exercise</button>
        <button id="listenBtn" class="secondary">üéôÔ∏è Voice On</button>
        <button id="muteBtn" class="secondary">üîä Mute</button>
        <button id="dashboardBtn" class="secondary" disabled>üìä My Dashboard</button>

        <select id="voiceSelect">
          <option value="">Loading voices‚Ä¶</option>
        </select>

        <span class="chip">
          <span class="chip-dot"></span>
          <span id="brainChipText">Ma‚Äôat 2.0: connecting‚Ä¶</span>
        </span>
      </div>

      <div class="status-line"><strong>Pose:</strong> <span id="poseStatus">Not started.</span></div>
      <div class="status-line"><strong>Brain:</strong> <span id="brainStatus">Not contacted yet.</span></div>
      <div class="status-line"><strong>Exercise:</strong> <span id="exerciseLabel">Bodyweight Squat</span></div>
      <div class="status-line"><strong>Reps (this set):</strong> <span id="repCount">0</span></div>
      <div id="voiceSupportStatus"></div>
    </div>

    <!-- RIGHT: Profile + Today‚Äôs workout + calendar + chat -->
    <div class="pane">
      <h2>Profile</h2>
      <p class="subtitle">Ma‚Äôat 2.0 remembers you and builds long-term programs from here.</p>

      <div id="profileSummary" class="small-card">Not signed in yet.</div>

      <h2 style="margin-top:12px;">Today‚Äôs Workout</h2>
      <p class="subtitle">Choose a template or use Ma‚Äôat 2.0‚Äôs program from your assessment.</p>

      <select id="workoutSelect">
        <option value="">‚Äî Select a workout ‚Äî</option>
        <option value="ai_today">Ma‚Äôat 2.0 ‚Äì Today‚Äôs Program</option>
        <option value="nasm_total_body_a">NASM Total Body A (Template)</option>
        <option value="yoga_back_release">Yoga Back Release Flow (Template)</option>
      </select>

      <div id="workoutPlanView">
        Your workout plan will appear here after you sign in and select or generate a program.
      </div>

      <h2 style="margin-top:12px;">Workout Calendar</h2>
      <p class="subtitle">Gold = today, green = workout days (solid green = completed).</p>
      <div id="calendarView"></div>

      <h2 style="margin-top:12px;">Overhead Squat Assessment</h2>
      <p class="subtitle">Run the assessment first. Ma‚Äôat 2.0 will read your movement and build your plan.</p>
      <div id="ohsSummaryView">No assessment run yet.</div>

      <h2 style="margin-top:12px;">Mufasa Chat</h2>
      <p class="subtitle">Talk or type. Say ‚ÄúMufasa ‚Ä¶‚Äù or ‚ÄúCoach ‚Ä¶‚Äù for hands-free coaching.</p>
      <div style="display:flex; gap:8px;">
        <input id="questionInput" type="text" placeholder="Ask or speak to your coach..." />
        <button id="askBtn">Ask</button>
      </div>
      <div id="coach-log"></div>
    </div>
  </div>

  <script>
    console.log("üî• Ma‚Äôat 2.0 coach script initialized");

    /* =========================================================
      SECTION 1/4 ‚Äî CONFIG + DOM HOOKS + CORE STATE
      (Critical fix: define DOM refs BEFORE any functions use them,
       so there‚Äôs no const/let TDZ issues.)
    ========================================================== */

    // ---- Backend endpoints ----
    const BRAIN_BASE_URL = "https://mufasabrain.onrender.com";
    const ASK_URL = BRAIN_BASE_URL + "/ask";
    const PROGRAM_URL = BRAIN_BASE_URL + "/coach/program/generate";

    const NODE_BASE_URL = "https://mufasa-fitness-node.onrender.com";
    const NODE_COMMAND_URL = NODE_BASE_URL + "/command";

    // ---- DOM hooks ----
    const overlay = document.getElementById("loginOverlay");
    const googleBtn = document.getElementById("googleBtn");
    const manualNameInput = document.getElementById("manualName");
    const manualLoginBtn = document.getElementById("manualLoginBtn");
    const userInfoBar = document.getElementById("userInfo");
    const userPicEl = document.getElementById("userPic");
    const userNameEl = document.getElementById("userName");
    const signOutBtn = document.getElementById("signOutBtn");
    const profileSummaryEl = document.getElementById("profileSummary");
    const voiceSupportStatusEl = document.getElementById("voiceSupportStatus");
    const voiceSelectEl = document.getElementById("voiceSelect");

    const videoEl = document.getElementById("video");
    const canvasEl = document.getElementById("overlay");
    const ctx = canvasEl.getContext("2d");

    const poseStatusEl = document.getElementById("poseStatus");
    const brainStatusEl = document.getElementById("brainStatus");
    const brainChipTxt = document.getElementById("brainChipText");

    const connectBtn = document.getElementById("connectBtn");
    const startBtn = document.getElementById("startBtn");
    const ohsaBtn = document.getElementById("ohsaBtn");
    const defineExerciseBtn = document.getElementById("defineExerciseBtn");
    const muteBtn = document.getElementById("muteBtn");
    const askBtn = document.getElementById("askBtn");
    const questionInput = document.getElementById("questionInput");
    const listenBtn = document.getElementById("listenBtn");
    const logEl = document.getElementById("coach-log");
    const repCountEl = document.getElementById("repCount");
    const exerciseLabelEl = document.getElementById("exerciseLabel");
    const workoutSelectEl = document.getElementById("workoutSelect");
    const workoutPlanViewEl = document.getElementById("workoutPlanView");
    const ohsaSummaryViewEl = document.getElementById("ohsSummaryView");
    const calendarViewEl = document.getElementById("calendarView");
    const dashboardBtn = document.getElementById("dashboardBtn");

    // ---- Global user/session state ----
    let USER_ID = "guest";
    let USER_PROFILE = null;
    let calendarMeta = null; // {startDateISO, weeks, daysPerWeek, completedDates:Set<string>}

    // ---- Pose / workout state ----
    let detector;
    let running = false;
    let animId;

    let sessionId = null;
    let repCount = 0;      // this set
    let totalReps = 0;     // across all sets
    let currentSet = 1;
    let repPhase = "up";

    let fullBodyAcquired = false;
    let lastStepBackSpokenAt = 0;
    let lastGoodRepSpokenAt = 0;

    let lastNodeRepSentAt = 0;
    let lastDepthScore = 0;
    let lastGoodForm = false;

    const STEP_BACK_COOLDOWN = 4000;
    const GOOD_REP_COOLDOWN  = 2500;

    // ---- New Exercise definition ----
    let definingExercise = false;
    let definedExercises = {};        // { name: { depthScoreAvg, torsoAngleAvg, samples } }
    let currentExerciseName = null;
    const EXERCISE_BASELINE_FRAMES = 80;
    let baselineFrames = [];

    // ---- Overhead Squat Assessment ----
    let ohsaMode = false;
    let ohsaPhase = null;             // "front" or "side"
    let ohsaFrontSamples = [];
    let ohsaSideSamples = [];
    const OHSA_TARGET_SAMPLES_PER_VIEW = 40;
    let lastOhsaSummary = null;

    // ---- AI-generated program ----
    let aiProgramToday = null;

    // Default exercise + workout prescription
    const EXERCISE_ID = "bodyweight_squat";
    const TARGET_REPS = 10;
    const TARGET_SETS = 3;

    // Skeleton edges for MoveNet keypoints (indices 0‚Äì16)
    const SKELETON_EDGES = [
      [5, 7], [7, 9],
      [6, 8], [8, 10],
      [5, 6],
      [5, 11], [6, 12],
      [11, 12],
      [11, 13], [13, 15],
      [12, 14], [14, 16]
    ];

    /* =========================================================
      SECTION 2/4 ‚Äî UI HELPERS + LOGIN/PERSIST + CALENDAR
    ========================================================== */

    function addLog(kind, text) {
      const div = document.createElement("div");
      div.className = "log-line " + kind;
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function showOverlay(show) {
      if (show) overlay.classList.remove("hidden");
      else overlay.classList.add("hidden");
    }

    function persistUser() {
      try {
        localStorage.setItem("maatUserId", USER_ID);
        localStorage.setItem("maatUserProfile", JSON.stringify(USER_PROFILE || {}));
        if (calendarMeta) {
          const metaJSON = {
            startDateISO: calendarMeta.startDateISO,
            weeks: calendarMeta.weeks,
            daysPerWeek: calendarMeta.daysPerWeek,
            completed: Array.from(calendarMeta.completedDates || [])
          };
          localStorage.setItem("maatCalendar_" + USER_ID, JSON.stringify(metaJSON));
        }
      } catch (e) {
        console.warn("localStorage error", e);
      }
    }

    function defaultProfileForName(name) {
      const lower = (name || "").toLowerCase();
      if (lower === "rashad" || lower === "rashad harbor") {
        return {
          name: "Rashad",
          age: 38,
          weight_lbs: 150,
          height: "5'5\"",
          injuries: ["3 herniated discs (lumbar)"],
          history: { chiropractic_months: 12, yoga_years: 2 },
          goals: {
            primary: "Gain 20 lb of muscle in ~3 months",
            style: "Home workouts only + heavy yoga",
            frequency_days_per_week: 4,
            focus: "Muscle gain + back decompression / pain-free movement"
          }
        };
      }
      return {
        name: name || "Athlete",
        age: null,
        weight_lbs: null,
        height: null,
        injuries: [],
        history: {},
        goals: {
          primary: "Build full-body strength and mobility",
          style: "Home workouts + yoga focus",
          frequency_days_per_week: 3,
          focus: "Consistent training and recovery"
        }
      };
    }

    function onLoginUI(profile) {
      userInfoBar.style.display = "flex";
      userPicEl.src = profile.picture || "https://i.imgur.com/9z3s8Gh.png";
      userNameEl.textContent = profile.name || "User";

      const inj = (profile.injuries && profile.injuries.length)
        ? profile.injuries.join(", ")
        : "None listed";

      const goalText = profile.goals && profile.goals.primary
        ? profile.goals.primary
        : "Build strength and mobility";

      profileSummaryEl.innerHTML =
        `<strong>Signed in as ${profile.name || "User"}</strong><br/>` +
        (profile.age ? `Age: ${profile.age}<br/>` : "") +
        (profile.height ? `Height: ${profile.height}<br/>` : "") +
        (profile.weight_lbs ? `Weight: ${profile.weight_lbs} lb<br/>` : "") +
        `Goal: ${goalText}<br/>` +
        `Injuries: ${inj}`;
    }

    function buildCalendarFromMeta() {
      if (!calendarMeta) {
        calendarViewEl.textContent = "No calendar yet. Run an assessment to generate a plan.";
        return;
      }

      const meta = calendarMeta;
      const startDate = new Date(meta.startDateISO);
      startDate.setHours(0,0,0,0);

      const today = new Date();
      today.setHours(0,0,0,0);
      const todayKey = today.toISOString().slice(0,10);

      // Build workout day set for next meta.weeks weeks
      const workoutDates = new Set();
      let d = new Date(startDate);
      for (let w = 0; w < meta.weeks; w++) {
        for (let day = 0; day < 7; day++) {
          if (day < meta.daysPerWeek) {
            workoutDates.add(d.toISOString().slice(0,10));
          }
          d.setDate(d.getDate() + 1);
        }
      }

      const completed = meta.completedDates || new Set();

      const baseMonth = today.getMonth();
      const baseYear = today.getFullYear();

      const firstOfMonth = new Date(baseYear, baseMonth, 1);
      const startWeekday = firstOfMonth.getDay(); // 0=Sun
      const daysInMonth = new Date(baseYear, baseMonth + 1, 0).getDate();
      const monthName = firstOfMonth.toLocaleString("default", { month: "long" });

      const header = document.createElement("div");
      header.className = "cal-header";
      header.textContent = monthName + " " + baseYear;

      const grid = document.createElement("div");
      grid.className = "cal-grid";

      const dayLabels = ["S","M","T","W","T","F","S"];
      for (const label of dayLabels) {
        const dl = document.createElement("div");
        dl.className = "cal-day-label";
        dl.textContent = label;
        grid.appendChild(dl);
      }

      for (let i = 0; i < startWeekday; i++) {
        const cell = document.createElement("div");
        cell.className = "cal-cell cal-empty";
        grid.appendChild(cell);
      }

      for (let day = 1; day <= daysInMonth; day++) {
        const cell = document.createElement("div");
        cell.className = "cal-cell";
        const dateObj = new Date(baseYear, baseMonth, day);
        dateObj.setHours(0,0,0,0);
        const key = dateObj.toISOString().slice(0,10);

        const span = document.createElement("div");
        span.className = "cal-date";
        span.textContent = day;
        cell.appendChild(span);

        if (key === todayKey) cell.classList.add("cal-today");
        if (workoutDates.has(key)) cell.classList.add("cal-workout");
        if (completed.has(key)) cell.classList.add("cal-done");

        grid.appendChild(cell);
      }

      calendarViewEl.innerHTML = "";
      calendarViewEl.appendChild(header);
      calendarViewEl.appendChild(grid);
    }

    function sendToNode(payload) {
      fetch(NODE_COMMAND_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      }).catch(e => console.warn("Node send failed", e));
    }

    function sendProfileToNode() {
      if (!USER_PROFILE) return;
      sendToNode({
        domain: "fitness",
        command: "fitness.saveProfile",
        userId: USER_ID,
        payload: { profile: USER_PROFILE, ts: Date.now() }
      });
      addLog("system", "Profile sent to Ma‚Äôat 2.0 backend.");
    }

    function onLogin(profile) {
      USER_ID = (profile.email || profile.name || "user").toLowerCase().replace(/\s+/g, "_");

      USER_PROFILE = {
        name: profile.name || profile.email || "Athlete",
        email: profile.email || null,
        picture: profile.picture || null,
        age: profile.age || profile.ageYears || null,
        weight_lbs: profile.weight_lbs || null,
        height: profile.height || null,
        injuries: profile.injuries || [],
        history: profile.history || {},
        goals: profile.goals || defaultProfileForName(profile.name).goals
      };

      if (!USER_PROFILE.injuries) USER_PROFILE.injuries = [];
      if (!USER_PROFILE.history) USER_PROFILE.history = {};
      if (!USER_PROFILE.goals) USER_PROFILE.goals = defaultProfileForName(profile.name).goals;

      if (!calendarMeta) {
        const today = new Date();
        today.setHours(0,0,0,0);
        calendarMeta = {
          startDateISO: today.toISOString().slice(0,10),
          weeks: 12,
          daysPerWeek: USER_PROFILE.goals.frequency_days_per_week || 4,
          completedDates: new Set()
        };
      }

      onLoginUI(USER_PROFILE);

      dashboardBtn.disabled = false;
      dashboardBtn.onclick = () => { window.location.href = "/public/dashboard.html"; };

      persistUser();
      sendProfileToNode();
      buildCalendarFromMeta();
    }

    function loadPersistedUser() {
      try {
        const id = localStorage.getItem("maatUserId");
        const profileStr = localStorage.getItem("maatUserProfile");

        if (id && profileStr) {
          USER_ID = id;
          USER_PROFILE = JSON.parse(profileStr);

          const calStr = localStorage.getItem("maatCalendar_" + USER_ID);
          if (calStr) {
            const meta = JSON.parse(calStr);
            calendarMeta = {
              startDateISO: meta.startDateISO,
              weeks: meta.weeks,
              daysPerWeek: meta.daysPerWeek,
              completedDates: new Set(meta.completed || [])
            };
          }

          onLoginUI(USER_PROFILE);

          dashboardBtn.disabled = false;
          dashboardBtn.onclick = () => { window.location.href = "/public/dashboard.html"; };

          showOverlay(false);
          return true;
        }
      } catch (e) {
        console.warn("loadPersistedUser error", e);
      }
      return false;
    }

    function parseJwt(token) {
      try {
        const base64Url = token.split(".")[1];
        const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
        const jsonPayload = decodeURIComponent(
          atob(base64).split("").map(c => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)).join("")
        );
        return JSON.parse(jsonPayload);
      } catch (e) {
        console.warn("JWT parse error", e);
        return {};
      }
    }

    // Login buttons
    manualLoginBtn.onclick = () => {
      const name = manualNameInput.value.trim() || "Athlete";
      onLogin(defaultProfileForName(name));
      showOverlay(false);
    };

    googleBtn.onclick = () => {
      if (!window.google || !google.accounts || !google.accounts.id) {
        alert("Google login not available on this device. Use username login instead.");
        return;
      }
      google.accounts.id.initialize({
        client_id: "1053883905933-n4a6ll6m7l3lqd60mq3g2rnb6iktdgp2.apps.googleusercontent.com",
        callback: (response) => {
          const payload = parseJwt(response.credential || "");
          onLogin({
            name: payload.name || payload.given_name || "Athlete",
            email: payload.email,
            picture: payload.picture
          });
          showOverlay(false);
        }
      });
      google.accounts.id.prompt();
    };

    signOutBtn.onclick = () => {
      const oldId = USER_ID;

      USER_ID = "guest";
      USER_PROFILE = null;
      calendarMeta = null;

      userInfoBar.style.display = "none";
      profileSummaryEl.textContent = "Not signed in yet.";

      dashboardBtn.disabled = true;

      try {
        localStorage.removeItem("maatUserId");
        localStorage.removeItem("maatUserProfile");
        localStorage.removeItem("maatCalendar_" + oldId);
      } catch (_) {}

      showOverlay(true);
    };

/* =========================================================
  SECTION 3/4 ‚Äî VOICE (AI streaming blob + browser fallback) + STT
========================================================== */

// ---- DOM ----
// Add this <audio> somewhere in HTML OR create it here:
let ttsPlayer = document.getElementById("ttsPlayer");
if (!ttsPlayer) {
  ttsPlayer = document.createElement("audio");
  ttsPlayer.id = "ttsPlayer";
  ttsPlayer.preload = "auto";
  document.body.appendChild(ttsPlayer);
}

// ---- Capability checks ----
const hasSpeechSynth = "speechSynthesis" in window;
const SRClass = window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SRClass && !hasSpeechSynth) {
  voiceSupportStatusEl.textContent = "This device does not support voice. Text only.";
} else if (!SRClass) {
  voiceSupportStatusEl.textContent = "Mic input not supported here. Text + AI voice output only.";
} else {
  voiceSupportStatusEl.textContent = "Voice ready. Tap 'Voice On' to enable audio + mic.";
  voiceSupportStatusEl.classList.add("status-ok");
}

// ---- Voice dropdown (controls backend voice) ----
// Your backend expects: { text, voice, format }
// So dropdown values should be voices like: alloy, verse, etc.
(function initVoiceDropdown() {
  if (!voiceSelectEl) return;
  const voices = ["alloy", "verse", "aria", "ember", "coral"]; // adjust if you want
  voiceSelectEl.innerHTML = "";
  voices.forEach(v => {
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    voiceSelectEl.appendChild(opt);
  });
  voiceSelectEl.value = "alloy";
})();

// ---- State ----
let voiceMuted = false;
let audioUnlocked = false;
let speechLock = false;        // LLM voice lock
let repFeedbackAllowed = true; // rep voice allowed when no LLM talking

function stopAllSpeech() {
  try { window.speechSynthesis?.cancel?.(); } catch {}
  try {
    ttsPlayer.pause();
    ttsPlayer.currentTime = 0;
  } catch {}
}

// ---- IMPORTANT: unlock audio once from a user click ----
async function unlockAudioOnce() {
  if (audioUnlocked) return true;
  try {
    // play a tiny silent sound to satisfy autoplay policies
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    gain.gain.value = 0.00001;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.02);
    await ctx.resume();
    audioUnlocked = true;
    voiceSupportStatusEl.textContent = "Audio unlocked ‚úÖ Voice will play now.";
    voiceSupportStatusEl.classList.add("status-ok");
    return true;
  } catch (e) {
    console.warn("Audio unlock failed:", e);
    voiceSupportStatusEl.textContent =
      "Tap the page once more to enable audio (browser autoplay protection).";
    return false;
  }
}

// ---- AI TTS (STREAMING BLOB) ----
// This matches YOUR FastAPI server: it returns audio bytes (mp3/wav)
const AIVOICE_URL = "/api/voice/speak";


async function speak(text, source = "system") {
  if (voiceMuted || !text || !text.trim()) return;
  if (speechLock && source === "rep") return;

  // If audio isn't unlocked yet, we can't auto-play
  if (!audioUnlocked) {
    // Try unlock (works only if speak() was triggered by a user click)
    const ok = await unlockAudioOnce();
    if (!ok) return;
  }

  const voice = (voiceSelectEl?.value || "alloy");
  const format = "mp3";

  try {
    stopAllSpeech();

    // lock while LLM is talking
    if (source === "llm") {
      speechLock = true;
      repFeedbackAllowed = false;
    }

    const res = await fetch(AIVOICE_URL, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ text, voice, format })
});

if (!res.ok) {
  const errTxt = await res.text().catch(() => "");
  throw new Error("TTS HTTP " + res.status + " " + errTxt);
}


    // ‚úÖ blob because backend streams audio bytes
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    ttsPlayer.src = url;
    ttsPlayer.onended = () => {
      URL.revokeObjectURL(url);
      if (source === "llm") {
        speechLock = false;
        repFeedbackAllowed = true;
      }
    };
    ttsPlayer.onerror = () => {
      URL.revokeObjectURL(url);
      if (source === "llm") {
        speechLock = false;
        repFeedbackAllowed = true;
      }
    };

    await ttsPlayer.play();
    return;

  } catch (e) {
    console.warn("AI voice failed:", e);

    // Optional browser fallback
    if (hasSpeechSynth) {
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 0.95;
        u.pitch = 1.0;
        u.onend = () => {
          if (source === "llm") {
            speechLock = false;
            repFeedbackAllowed = true;
          }
        };
        window.speechSynthesis.speak(u);
      } catch (err) {
        console.warn("Fallback TTS failed:", err);
      }
    }

    if (source === "llm") {
      speechLock = false;
      repFeedbackAllowed = true;
    }
  }
}



// ---- STT (Speech Recognition) ----
let listening = false;
let recognition = null;
let lastTranscript = "";

function toggleListening() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) {
    alert("Speech recognition not supported in this browser.");
    return;
  }

  if (!recognition) {
    recognition = new SR();
    recognition.lang = "en-US";
    recognition.continuous = true;
    recognition.interimResults = false;

    recognition.onresult = e => {
      const transcript = e.results?.[e.results.length - 1]?.[0]?.transcript?.trim() || "";
      if (!transcript || transcript === lastTranscript) return;
      lastTranscript = transcript;

      const lower = transcript.toLowerCase();
      console.log("STT:", transcript);

      if (lower.includes("mufasa") || lower.includes("coach")) {
        stopAllSpeech();
        const cleaned = lower.replace("hey", "").replace("mufasa", "").replace("coach", "").trim();
        const msg = cleaned || "give me a quick status update on my workout.";
        addLog("you", "üéôÔ∏è " + transcript);
        askCoach(msg);
      }
    };

    recognition.onerror = e => {
      console.warn("STT error:", e.error);
      addLog("system", "STT error: " + e.error);
    };

    recognition.onend = () => {
      if (listening) {
        try { recognition.start(); } catch {}
      }
    };
  }

  if (!listening) {
    listening = true;
    lastTranscript = "";
    recognition.start();
    addLog("system", "Listening for 'Mufasa' or 'Coach'...");
  } else {
    listening = false;
    recognition.stop();
    addLog("system", "Stopped listening.");
  }
}


    /* =========================================================
      SECTION 4/4 ‚Äî POSE ENGINE + OHSA + WORKOUT + CHAT
    ========================================================== */

    // Static workout templates
    const STATIC_WORKOUTS = {
      nasm_total_body_a:
        "Warm-up (5‚Äì10 min):\n" +
        "- Cat‚Äìcow x10, Hip circles x10/side, Arm swings x20\n\n" +
        "Strength (2‚Äì3 rounds):\n" +
        "- Squat to press x12\n" +
        "- Row (band or backpack) x12\n" +
        "- Glute bridge x15\n\n" +
        "Cool-down: light stretching for hips, hamstrings, chest.",
      yoga_back_release:
        "Yoga Back Release Flow (~25 min):\n" +
        "- Child‚Äôs pose (3‚Äì5 breaths)\n" +
        "- Cat‚Äìcow x10\n" +
        "- Low lunge with side bend (5 breaths/side)\n" +
        "- Sphinx pose (8‚Äì10 breaths)\n" +
        "- Supine twist (5‚Äì8 breaths/side)\n" +
        "- Legs up the wall (2‚Äì3 min)."
    };

    function getKeypoint(pose, name) {
      if (!pose || !pose.keypoints) return null;
      return pose.keypoints.find(k => k.name === name || k.part === name) || null;
    }

    function getAngleDegrees(a, b, c) {
      if (!a || !b || !c) return null;
      const abx = a.x - b.x;
      const aby = a.y - b.y;
      const cbx = c.x - b.x;
      const cby = c.y - b.y;
      const dot = abx * cbx + aby * cby;
      const magAB = Math.hypot(abx, aby);
      const magCB = Math.hypot(cbx, cby);
      if (!magAB || !magCB) return null;
      const cos = dot / (magAB * magCB);
      const clamped = Math.min(1, Math.max(-1, cos));
      return (Math.acos(clamped) * 180) / Math.PI;
    }

    function computeKneeValgus(leftHip, rightHip, leftKnee, rightKnee) {
      if (!leftHip || !rightHip || !leftKnee || !rightKnee) return 0;
      const hipWidth = Math.abs(rightHip.x - leftHip.x);
      const kneeWidth = Math.abs(rightKnee.x - leftKnee.x);
      if (!hipWidth) return 0;
      return (hipWidth - kneeWidth) / hipWidth;
    }

    function analyzeSquatForm(pose) {
      if (!pose) {
        return { fullBody:false, depthScore:0, goodForm:false, kneeAngle:180, torsoAngle:90, kneeValgus:0 };
      }

      const leftHip   = getKeypoint(pose, "left_hip");
      const rightHip  = getKeypoint(pose, "right_hip");
      const leftKnee  = getKeypoint(pose, "left_knee");
      const rightKnee = getKeypoint(pose, "right_knee");
      const leftAnkle = getKeypoint(pose, "left_ankle");
      const rightAnkle= getKeypoint(pose, "right_ankle");
      const leftShoulder  = getKeypoint(pose, "left_shoulder");
      const rightShoulder = getKeypoint(pose, "right_shoulder");

      const required = [leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle];
      const fullBody = required.every(k => k && k.score > 0.3);

      const leftKneeAngle  = getAngleDegrees(leftHip,  leftKnee,  leftAnkle);
      const rightKneeAngle = getAngleDegrees(rightHip, rightKnee, rightAnkle);
      const kneeAngle = (leftKneeAngle + rightKneeAngle) / 2 || 180;

      const depthScore = Math.max(0, Math.min(1, (180 - kneeAngle) / 90));

      const leftTorsoAngle  = getAngleDegrees(leftShoulder,  leftHip,  leftAnkle);
      const rightTorsoAngle = getAngleDegrees(rightShoulder, rightHip, rightAnkle);
      const torsoAngle = (leftTorsoAngle + rightTorsoAngle) / 2 || 90;

      const kneeValgus = computeKneeValgus(leftHip, rightHip, leftKnee, rightKnee);

      const deepEnough = depthScore > 0.6;
      const notTooDeep = kneeAngle > 50;
      const torsoOk    = torsoAngle > 60;

      const goodForm = fullBody && deepEnough && notTooDeep && torsoOk;
      return { fullBody, depthScore, goodForm, kneeAngle, torsoAngle, kneeValgus };
    }

    function sendStartSessionToNode() {
      sendToNode({
        domain: "fitness",
        command: "fitness.startSession",
        userId: USER_ID,
        payload: { sessionId, programId: null, exerciseId: EXERCISE_ID, ts: Date.now() }
      });
    }

    function sendEndSessionToNode() {
      if (!sessionId) return;
      sendToNode({
        domain: "fitness",
        command: "fitness.endSession",
        userId: USER_ID,
        payload: { sessionId, repsCompleted: totalReps, exerciseId: EXERCISE_ID, ts: Date.now() }
      });

      if (calendarMeta) {
        const today = new Date();
        today.setHours(0,0,0,0);
        const key = today.toISOString().slice(0,10);
        calendarMeta.completedDates.add(key);
        buildCalendarFromMeta();
        persistUser();
      }
    }

    function sendRepToNode(depthScore) {
      const now = Date.now();
      if (now - lastNodeRepSentAt < 500) return;
      lastNodeRepSentAt = now;

      sendToNode({
        domain: "fitness",
        command: "fitness.repUpdate",
        userId: USER_ID,
        payload: {
          sessionId,
          exerciseId: EXERCISE_ID,
          repsThisSet: repCount,
          totalReps,
          depthScore,
          ts: now
        }
      });
    }

    function sendOhsaToNode(summary) {
      sendToNode({
        domain: "fitness",
        command: "fitness.ohsaResult",
        userId: USER_ID,
        payload: { summary, ts: Date.now() }
      });
    }

    // Brain health ping
    (async () => {
      try {
        const res = await fetch(BRAIN_BASE_URL + "/health");
        await res.json();
        brainStatusEl.textContent = "Ma‚Äôat 2.0 online.";
        brainStatusEl.classList.add("status-ok");
        brainChipTxt.textContent = "Ma‚Äôat 2.0";
      } catch (e) {
        console.warn("Brain health error", e);
        brainStatusEl.textContent = "Ma‚Äôat 2.0 offline.";
        brainStatusEl.classList.add("status-bad");
        brainChipTxt.textContent = "Ma‚Äôat 2.0 (offline)";
      }
    })();

    async function initDetector() {
      await tf.setBackend("webgl");
      await tf.ready();
      if (typeof poseDetection === "undefined") {
        console.error("PoseDetection failed to load.");
        return;
      }
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
      console.log("‚úÖ MoveNet detector created.");
    }

    async function connectCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoEl.srcObject = stream;
        await new Promise(r => videoEl.onloadedmetadata = r);

        canvasEl.width = videoEl.videoWidth;
        canvasEl.height = videoEl.videoHeight;

        poseStatusEl.textContent = "Camera connected. Loading pose detector‚Ä¶";
        await initDetector();

        poseStatusEl.textContent = "Pose detector ready.";
        poseStatusEl.classList.add("status-ok");
        startBtn.disabled = false;
        ohsaBtn.disabled = false;
        defineExerciseBtn.disabled = false;
      } catch (e) {
        console.error("Camera error", e);
        poseStatusEl.textContent = "Camera error.";
        poseStatusEl.classList.add("status-bad");
      }
    }

    async function askCoach(q, options = { speakAnswer: true }) {
      if (!q) return;
      addLog("you", "You: " + q);
      questionInput.value = "";
      brainStatusEl.textContent = "Ma‚Äôat 2.0 thinking‚Ä¶";

      const telemetry = {
        exercise_id: EXERCISE_ID,
        reps: totalReps,
        depth_score: lastDepthScore,
        good_form: lastGoodForm
      };

      const contextObj = {
        profile: USER_PROFILE,
        last_ohsa: lastOhsaSummary || null
      };

      try {
        const res = await fetch(ASK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            question: q,
            user_id: USER_ID,
            session_id: sessionId,
            telemetry,
            context: JSON.stringify(contextObj)
          })
        });
        const data = await res.json();
        const answer = data.answer || data.response || "No response.";
        addLog("coach", "Ma‚Äôat 2.0: " + answer);
        if (options.speakAnswer) speak(answer, "llm");
        brainStatusEl.textContent = "Ma‚Äôat 2.0 responded.";
        return answer;
      } catch (e) {
        console.error("Brain error", e);
        brainStatusEl.textContent = "Ma‚Äôat 2.0 error.";
        addLog("system", "Network error contacting Ma‚Äôat 2.0.");
        return null;
      }
    }

    async function generateProgramFromOhsa(summary) {
      if (!summary) return;

      const question =
        "You are Ma‚Äôat 2.0, my NASM-informed Pan-African virtual coach. " +
        "Using this Overhead Squat Assessment result and my profile, " +
        "design a 3-month plan and show ONLY today‚Äôs workout from that plan.\n\n" +
        "Constraints:\n" +
        "- Goal: gain 20 lb of muscle in 3 months.\n" +
        "- Workouts: ~4 days per week.\n" +
        "- Home workouts only.\n" +
        "- Heavy on yoga and corrective exercise for lumbar herniated discs.\n" +
        "- Use your NASM Movement Basics, Overhead Squat Assessment patterns, gymnastics fundamentals, and yoga CSV knowledge.\n\n" +
        "Overhead Squat Assessment (JSON):\n" +
        JSON.stringify(summary, null, 2) + "\n\n" +
        "My profile (JSON):\n" +
        JSON.stringify(USER_PROFILE || {}, null, 2) + "\n\n" +
        "Return a clear, numbered breakdown for TODAY ONLY.";

      addLog("system", "Sending OHSA + profile to Ma‚Äôat 2.0 to generate today‚Äôs workout‚Ä¶");
      const answer = await askCoach(question, { speakAnswer: false });
      if (!answer) return;

      aiProgramToday = answer;
      workoutSelectEl.value = "ai_today";
      workoutPlanViewEl.textContent = aiProgramToday;
      addLog("system", "Ma‚Äôat 2.0 created today‚Äôs program from your assessment.");

      try {
        const res = await fetch(PROGRAM_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            user_id: USER_ID,
            goal: "Gain 20 lb muscle in 3 months",
            weeks: 12,
            days_per_week: 4,
            home_only: true,
            yoga_heavy: true,
            assessment_summary: JSON.stringify(summary),
            extra_context: "",
            start_date: new Date().toISOString().slice(0,10),
            created_by: USER_ID
          })
        });
        const data = await res.json();
        if (data && data.program) {
          const prog = data.program;
          const weeks = prog.weeks || 12;
          const daysPerWeek = prog.days_per_week || 4;
          const today = new Date();
          today.setHours(0,0,0,0);
          calendarMeta = {
            startDateISO: today.toISOString().slice(0,10),
            weeks,
            daysPerWeek,
            completedDates: new Set()
          };
          buildCalendarFromMeta();
          persistUser();
          addLog("system", "Calendar updated from Ma‚Äôat 2.0 program.");
        }
      } catch (e) {
        console.warn("Program API error", e);
      }
    }

    function startDefineExercise() {
      if (!detector) { alert("Connect camera first."); return; }
      if (running || ohsaMode) { alert("Stop workout / assessment before defining a new exercise."); return; }

      const name = prompt("Name this exercise (e.g. single_leg_squat_right):");
      if (!name) return;

      definingExercise = true;
      currentExerciseName = name;
      baselineFrames = [];
      addLog("system", `Defining new exercise: ${name}. Give me several GOOD reps.`);
      speak(`Okay. Let's define ${name}. Give me your best form for several reps so I can learn this move.`, "rep");

      runPoseLoop();
    }

    function finishDefineExercise() {
      if (!definingExercise || baselineFrames.length === 0 || !currentExerciseName) return;

      const depthValues = baselineFrames.map(f => f.depthScore);
      const torsoValues = baselineFrames.map(f => f.torsoAngle);
      const avgDepth = depthValues.reduce((a, b) => a + b, 0) / depthValues.length;
      const avgTorso = torsoValues.reduce((a, b) => a + b, 0) / torsoValues.length;

      definedExercises[currentExerciseName] = {
        name: currentExerciseName,
        depthScoreAvg: avgDepth,
        torsoAngleAvg: avgTorso,
        samples: baselineFrames.length,
        createdAt: Date.now()
      };

      addLog("system",
        `Exercise "${currentExerciseName}" learned. Depth avg: ${avgDepth.toFixed(2)}, torso avg: ${avgTorso.toFixed(1)} (samples: ${baselineFrames.length}).`
      );
      speak(`Got it. I saved your baseline for ${currentExerciseName}.`, "rep");

      definingExercise = false;
      currentExerciseName = null;
      baselineFrames = [];
    }

    function summarizeArray(arr, key) {
      if (!arr.length) return 0;
      const vals = arr.map(a => a[key]).filter(v => typeof v === "number");
      if (!vals.length) return 0;
      return vals.reduce((a, b) => a + b, 0) / vals.length;
    }

    function startOhsa() {
      if (!detector) { alert("Connect camera first."); return; }
      if (running || definingExercise) { alert("Stop the workout / exercise definition before running OHSA."); return; }

      ohsaMode = true;
      ohsaPhase = "front";
      ohsaFrontSamples = [];
      ohsaSideSamples = [];
      lastOhsaSummary = null;

      ohsaSummaryViewEl.textContent =
        "Running OHSA‚Ä¶ first: face the camera and give me several good overhead squats.";
      addLog("system", "OHSA started: front view first.");
      speak(
        "We are starting your overhead squat assessment. Face the camera, raise your arms overhead, and give me three to five slow squats with your best form.",
        "rep"
      );

      runPoseLoop();
    }

    function finishOhsa() {
      ohsaMode = false;

      const frontDepthAvg   = summarizeArray(ohsaFrontSamples, "depthScore");
      const frontKneeValgus = summarizeArray(ohsaFrontSamples, "kneeValgus");
      const sideDepthAvg    = summarizeArray(ohsaSideSamples, "depthScore");
      const sideTorsoAngle  = summarizeArray(ohsaSideSamples, "torsoAngle");

      const findings = [];
      if (frontKneeValgus > 0.15) findings.push("Knees tend to collapse inward (knee valgus) on squat.");
      if (sideTorsoAngle < 65) findings.push("Trunk leans forward more than ideal in the bottom of the squat.");
      if (sideDepthAvg < 0.5 || frontDepthAvg < 0.5) findings.push("Squat depth is limited (may indicate ankle or hip mobility restrictions).");
      if (!findings.length) findings.push("Movement pattern looks generally balanced with no major overhead-squat faults.");

      const summary = {
        front: { samples: ohsaFrontSamples.length, depthScoreAvg: frontDepthAvg, kneeValgusAvg: frontKneeValgus },
        side:  { samples: ohsaSideSamples.length, depthScoreAvg: sideDepthAvg,  torsoAngleAvg: sideTorsoAngle },
        findings
      };

      lastOhsaSummary = summary;
      sendOhsaToNode(summary);

      const textSummary =
        "Overhead Squat Assessment Summary:\n" +
        `- Front view samples: ${summary.front.samples}\n` +
        `  ¬∑ Avg depth score: ${summary.front.depthScoreAvg.toFixed(2)}\n` +
        `  ¬∑ Avg knee valgus: ${summary.front.kneeValgusAvg.toFixed(2)}\n` +
        `- Side view samples: ${summary.side.samples}\n` +
        `  ¬∑ Avg depth score: ${summary.side.depthScoreAvg.toFixed(2)}\n` +
        `  ¬∑ Avg torso angle: ${summary.side.torsoAngleAvg.toFixed(1)}¬∞\n\n` +
        "Key findings:\n- " + summary.findings.join("\n- ");

      ohsaSummaryViewEl.textContent = textSummary;
      addLog("system", "OHSA completed. Summary recorded and sent to Ma‚Äôat 2.0 backend.");
      speak("Your overhead squat assessment is complete. I‚Äôve logged your movement pattern and will build your plan from this.", "rep");

      generateProgramFromOhsa(summary);
    }

    async function runPoseLoop() {
      if (!running && !definingExercise && !ohsaMode) return;
      if (!detector) return;

      const poses = await detector.estimatePoses(videoEl, { flipHorizontal: true });
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

      const pose = poses.length ? poses[0] : null;
      const analysis = analyzeSquatForm(pose);

      lastDepthScore = analysis.depthScore;
      lastGoodForm = analysis.goodForm;

      const now = performance.now();

      // Status + coaching prompt
      if (!analysis.fullBody) {
        poseStatusEl.textContent = "No full body in view.";
        if (!fullBodyAcquired && repFeedbackAllowed && now - lastStepBackSpokenAt > STEP_BACK_COOLDOWN) {
          if (running || definingExercise || ohsaMode) speak("Step back so I can see your whole body.", "rep");
          lastStepBackSpokenAt = now;
        }
      } else {
        if (!fullBodyAcquired) {
          fullBodyAcquired = true;
          if (repFeedbackAllowed && (running || definingExercise || ohsaMode)) speak("Great, I can see your full body.", "rep");
        }
        poseStatusEl.textContent = analysis.goodForm
          ? `Form looks solid. Score: ${analysis.depthScore.toFixed(2)}`
          : `Form needs adjustment. Score: ${analysis.depthScore.toFixed(2)}`;
      }

      // Draw skeleton
      if (pose && pose.keypoints) {
        const color = analysis.goodForm ? "#22c55e" : "#ef4444";
        ctx.lineWidth = 3;

        for (const [i, j] of SKELETON_EDGES) {
          const kp1 = pose.keypoints[i];
          const kp2 = pose.keypoints[j];
          if (kp1 && kp2 && kp1.score > 0.4 && kp2.score > 0.4) {
            ctx.beginPath();
            ctx.moveTo(kp1.x, kp1.y);
            ctx.lineTo(kp2.x, kp2.y);
            ctx.strokeStyle = color;
            ctx.stroke();
          }
        }

        for (const kp of pose.keypoints) {
          if (kp.score > 0.4) {
            ctx.beginPath();
            ctx.arc(kp.x, kp.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
          }
        }
      }

      // Exercise baseline capture
      if (definingExercise && analysis.fullBody && analysis.goodForm) {
        baselineFrames.push({ depthScore: analysis.depthScore, torsoAngle: analysis.torsoAngle });

        if (baselineFrames.length === 1) addLog("system", "Recording exercise baseline‚Ä¶ keep moving with good form.");
        if (baselineFrames.length >= EXERCISE_BASELINE_FRAMES) finishDefineExercise();
      }

      // OHSA capture
      if (ohsaMode && analysis.fullBody) {
        const depth = analysis.depthScore;

        if (ohsaPhase === "front") {
          if (depth > 0.6 && ohsaFrontSamples.length < OHSA_TARGET_SAMPLES_PER_VIEW) ohsaFrontSamples.push(analysis);
          if (ohsaFrontSamples.length >= OHSA_TARGET_SAMPLES_PER_VIEW) {
            ohsaPhase = "side";
            addLog("system", "OHSA: front view captured. Turn sideways and keep squatting.");
            ohsaSummaryViewEl.textContent = "Front view captured. Now turn sideways to the camera and give me several more squats.";
            speak("Good. Now turn sideways to the camera and give me several more overhead squats with your best form.", "rep");
          }
        } else if (ohsaPhase === "side") {
          if (depth > 0.6 && ohsaSideSamples.length < OHSA_TARGET_SAMPLES_PER_VIEW) ohsaSideSamples.push(analysis);
          if (ohsaSideSamples.length >= OHSA_TARGET_SAMPLES_PER_VIEW) finishOhsa();
        }
      }

      // Workout rep counting
      if (running) {
        const depth = analysis.depthScore;
        const DOWN_THRESHOLD = 0.6;
        const UP_THRESHOLD   = 0.3;

        if (analysis.fullBody) {
          if (repPhase === "up" && depth > DOWN_THRESHOLD) {
            repPhase = "down";
          } else if (repPhase === "down" && depth < UP_THRESHOLD) {
            repPhase = "up";

            repCount += 1;
            totalReps += 1;
            repCountEl.textContent = String(repCount);
            sendRepToNode(depth);

            if (repFeedbackAllowed && now - lastGoodRepSpokenAt > GOOD_REP_COOLDOWN) {
              speak(analysis.goodForm ? "Good rep." : "Careful with your form on that rep.", "rep");
              lastGoodRepSpokenAt = now;
            }

            if (repCount === TARGET_REPS) {
              if (repFeedbackAllowed) speak(`Great job. That's ${TARGET_REPS} reps for set ${currentSet}.`, "rep");

              currentSet += 1;

              if (currentSet <= TARGET_SETS) {
                repCount = 0;
                setTimeout(() => {
                  if (running && repFeedbackAllowed) speak(`Rest is over. Let's start set ${currentSet}.`, "rep");
                }, 20000);
              } else {
                running = false;
                startBtn.textContent = "Start Workout";
                addLog("system", "Workout complete.");
                if (repFeedbackAllowed) speak("Workout complete. Strong work today.", "rep");
                sendEndSessionToNode();
                cancelAnimationFrame(animId);
                return;
              }
            }
          }
        }
      }

      animId = requestAnimationFrame(runPoseLoop);
    }

    async function startWorkout() {
      if (!detector) return;

      if (definingExercise) {
        definingExercise = false;
        baselineFrames = [];
        currentExerciseName = null;
        addLog("system", "Cancelled exercise definition to start workout.");
      }
      if (ohsaMode) {
        ohsaMode = false;
        ohsaFrontSamples = [];
        ohsaSideSamples = [];
        addLog("system", "Cancelled OHSA to start workout.");
      }

      running = !running;

      if (running) {
        sessionId = "sess_" + Date.now();
        repCount = 0;
        totalReps = 0;
        currentSet = 1;
        repPhase = "up";
        fullBodyAcquired = false;
        repCountEl.textContent = "0";

        startBtn.textContent = "Stop Workout";
        addLog("system", `Workout started: ${sessionId}`);
        speak(`We are doing ${TARGET_SETS} sets of ${TARGET_REPS} squats. When you're ready, let's begin.`, "rep");
        sendStartSessionToNode();
        runPoseLoop();
      } else {
        startBtn.textContent = "Start Workout";
        running = false;
        cancelAnimationFrame(animId);
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        addLog("system", "Workout stopped.");
        sendEndSessionToNode();
      }
    }

    function handleWorkoutSelectChange() {
      const val = workoutSelectEl.value;
      if (!val) {
        workoutPlanViewEl.textContent = "Your workout plan will appear here.";
        return;
      }
      if (val === "ai_today" && aiProgramToday) {
        workoutPlanViewEl.textContent = aiProgramToday;
      } else if (STATIC_WORKOUTS[val]) {
        workoutPlanViewEl.textContent = STATIC_WORKOUTS[val];
      } else {
        workoutPlanViewEl.textContent = "No plan found for that selection.";
      }
    }

    // ---- Wire buttons / events ----
    connectBtn.onclick = connectCamera;
    startBtn.onclick = startWorkout;
    ohsaBtn.onclick = startOhsa;
    defineExerciseBtn.onclick = startDefineExercise;

    askBtn.onclick = () => askCoach(questionInput.value.trim());

    muteBtn.onclick = () => {
      voiceMuted = !voiceMuted;
      muteBtn.textContent = voiceMuted ? "üîá Unmute" : "üîä Mute";
      if (voiceMuted) stopAllSpeech();
    };

    listenBtn.onclick = async () => {
  await unlockAudioOnce();
  toggleListening();
};

    workoutSelectEl.onchange = handleWorkoutSelectChange;

    questionInput.addEventListener("keydown", e => {
      if (e.key === "Enter") askCoach(questionInput.value.trim());
    });

    // ---- Boot ----
    window.addEventListener("load", () => {
      exerciseLabelEl.textContent = "Bodyweight Squat";
      addLog("system", "Page loaded. Connect your camera to begin.");

      // Auto-login (safe now: dashboardBtn is already defined)
      const didAuto = loadPersistedUser();
      if (didAuto && USER_PROFILE) {
        addLog("system", "Loaded your profile from memory.");
        buildCalendarFromMeta();
      }

      console.log("tf loaded:", typeof tf !== "undefined");
      console.log("poseDetection loaded:", typeof poseDetection !== "undefined");
    });
  </script>

  <!-- Keep your existing external script include -->
  <script src="/public/fitness.js"></script>
</body>
</html>
